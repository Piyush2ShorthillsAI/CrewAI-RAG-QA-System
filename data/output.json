[
{"url": "https://docs.crewai.com/introduction", "title": "Introduction - CrewAI", "content": "Build AI agent teams that work together to tackle complex tasks CrewAI empowers developers with both high-level simplicity and precise low-level control, ideal for creating autonomous AI agents tailored to any scenario: With over 100,000 developers certified through our community courses, CrewAI is rapidly becoming the standard for enterprise-ready AI automation. Just like a company has departments (Sales, Engineering, Marketing) working together under leadership to achieve business goals, CrewAI helps you create an organization of AI agents with specialized roles collaborating to accomplish complex tasks. CrewAI Framework Overview Create specialized agents with defined roles, expertise, and goals - from researchers to analysts to writers Equip agents with custom tools and APIs to interact with external services and data sources Agents work together, sharing insights and coordinating tasks to achieve complex objectives Define sequential or parallel workflows, with agents automatically handling task dependencies While Crews excel at autonomous collaboration, Flows provide structured automations, offering granular control over workflow execution. Flows ensure tasks are executed reliably, securely, and efficiently, handling conditional logic, loops, and dynamic state management with precision. Flows integrate seamlessly with Crews, enabling you to balance high autonomy with exacting control. CrewAI Framework Overview Define precise execution paths responding dynamically to events Manage workflow states and conditional execution securely and efficiently Effortlessly combine with Crews for enhanced autonomy and intelligence Ensure predictable outcomes with explicit control flow and error handling Understanding when to use   versus   is key to maximizing the potential of CrewAI in your applications. Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems. Learn how to create structured, event-driven workflows with precise control over execution. Get started with CrewAI in your development environment. Follow our quickstart guide to create your first CrewAI agent and get hands-on experience. Connect with other developers, get help, and share your CrewAI experiences. Was this page helpful?"},
{"url": "https://docs.crewai.com/examples/example", "title": "CrewAI Examples - CrewAI", "content": "A collection of examples that show how to use CrewAI framework to automate workflows. Automate marketing strategy creation with CrewAI. Create a surprise trip itinerary with CrewAI. Match a profile to jobpositions with CrewAI. Create a job posting with CrewAI. Create a game with CrewAI. Find job candidates with CrewAI. Was this page helpful?"},
{"url": "https://docs.crewai.com/introduction", "title": "Introduction - CrewAI", "content": "Build AI agent teams that work together to tackle complex tasks CrewAI empowers developers with both high-level simplicity and precise low-level control, ideal for creating autonomous AI agents tailored to any scenario: With over 100,000 developers certified through our community courses, CrewAI is rapidly becoming the standard for enterprise-ready AI automation. Just like a company has departments (Sales, Engineering, Marketing) working together under leadership to achieve business goals, CrewAI helps you create an organization of AI agents with specialized roles collaborating to accomplish complex tasks. CrewAI Framework Overview Create specialized agents with defined roles, expertise, and goals - from researchers to analysts to writers Equip agents with custom tools and APIs to interact with external services and data sources Agents work together, sharing insights and coordinating tasks to achieve complex objectives Define sequential or parallel workflows, with agents automatically handling task dependencies While Crews excel at autonomous collaboration, Flows provide structured automations, offering granular control over workflow execution. Flows ensure tasks are executed reliably, securely, and efficiently, handling conditional logic, loops, and dynamic state management with precision. Flows integrate seamlessly with Crews, enabling you to balance high autonomy with exacting control. CrewAI Framework Overview Define precise execution paths responding dynamically to events Manage workflow states and conditional execution securely and efficiently Effortlessly combine with Crews for enhanced autonomy and intelligence Ensure predictable outcomes with explicit control flow and error handling Understanding when to use   versus   is key to maximizing the potential of CrewAI in your applications. Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems. Learn how to create structured, event-driven workflows with precise control over execution. Get started with CrewAI in your development environment. Follow our quickstart guide to create your first CrewAI agent and get hands-on experience. Connect with other developers, get help, and share your CrewAI experiences. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/langchain-tools", "title": "Using LangChain Tools - CrewAI", "content": "Learn how to integrate LangChain tools with CrewAI agents to enhance search-based queries and more. CrewAI seamlessly integrates with LangChain\u2019s comprehensive  , all of which can be used with CrewAI. Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms,\nand the flexibility of tool arguments to optimize your agents\u2019 performance and capabilities. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/tools", "title": "Tools - CrewAI", "content": "Understanding and leveraging tools within the CrewAI framework for agent collaboration and task execution. CrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers.\nThis documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools. A tool in CrewAI is a skill or function that agents can utilize to perform various actions.\nThis includes tools from the   and  ,\nenabling everything from simple searches to complex interactions and effective teamwork among agents. To enhance your agents\u2019 capabilities with crewAI tools, begin by installing our extra tools package: Here\u2019s an example demonstrating their use: Here is a list of the available tools and their descriptions: Developers can craft   tailored for their agent\u2019s needs or\nutilize pre-built options. There are two main ways for one to create a CrewAI tool: The   class wraps functions as tools, providing flexibility and validation while reducing boilerplate. It supports custom schemas and dynamic logic for seamless integration of complex functionalities. Using  , you can wrap a function that interacts with an external API or system, providing a structured interface. This enables robust validation and consistent execution, making it easier to integrate complex functionalities into your applications as demonstrated in the following example: Tools can optionally implement a   to fine-tune caching\nbehavior. This function determines when to cache results based on specific\nconditions, offering granular control over caching logic. Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling,\ncaching mechanisms, and the flexibility of tool arguments to optimize your agents\u2019 performance and capabilities. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/cli", "title": "CLI - CrewAI", "content": "Learn how to use the CrewAI CLI to interact with CrewAI. The CrewAI CLI provides a set of commands to interact with CrewAI, allowing you to create, train, run, and manage crews & flows. To use the CrewAI CLI, make sure you have CrewAI installed: The basic structure of a CrewAI CLI command is: Create a new crew or flow. Example: Show the installed version of CrewAI. Example: Train the crew for a specified number of iterations. Example: Replay the crew execution from a specific task. Example: Retrieve your latest crew.kickoff() task outputs. Reset the crew memories (long, short, entity, latest_crew_kickoff_outputs). Example: Test the crew and evaluate the results. Example: Run the crew or flow. Starting from version 0.103.0, the   command can be used to run both standard crews and flows. For flows, it automatically detects the type from pyproject.toml and runs the appropriate command. This is now the recommended way to run both crews and flows. Make sure to run these commands from the directory where your CrewAI project is set up.\nSome commands may require additional configuration or setup within your project structure. Starting in version  , when you run the   command, you start an interactive session with your crew. The AI assistant will guide you by asking for necessary inputs to execute the crew. Once all inputs are provided, the crew will execute its tasks. After receiving the results, you can continue interacting with the assistant for further instructions or questions. Ensure you execute these commands from your CrewAI project\u2019s root directory. IMPORTANT: Set the   property in your   file to enable this command. When running   command, the CLI will first show you the top 5 most common LLM providers and ask you to select one. Once you\u2019ve selected an LLM provider, you will be prompted for API keys. The CLI will initially prompt for API keys for the following services: When you select a provider, the CLI will prompt you to enter your API key. If you select option 6, you will be able to select from a list of LiteLLM supported providers. When you select a provider, the CLI will prompt you to enter the Key name and the API key. See the following link for each provider\u2019s key name: Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/testing", "title": "Testing - CrewAI", "content": "Learn how to test your CrewAI Crew and evaluate their performance. Testing is a crucial part of the development process, and it is essential to ensure that your crew is performing as expected. With crewAI, you can easily test your crew and evaluate its performance using the built-in testing capabilities. We added the CLI command   to make it easy to test your crew. This command will run your crew for a specified number of iterations and provide detailed performance metrics. The parameters are   and  , which are optional and default to 2 and   respectively. For now, the only provider available is OpenAI. If you want to run more iterations or use a different model, you can specify the parameters like this: or using the short forms: When you run the   command, the crew will be executed for the specified number of iterations, and the performance metrics will be displayed at the end of the run. A table of scores at the end will show the performance of the crew in terms of the following metrics: The example above shows the test results for two runs of the crew with two tasks, with the average total score for each task and the crew as a whole. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/planning", "title": "Planning - CrewAI", "content": "Learn how to add planning to your CrewAI Crew and improve their performance. The planning feature in CrewAI allows you to add planning capability to your crew. When enabled, before each Crew iteration,\nall Crew information is sent to an AgentPlanner that will plan the tasks step by step, and this plan will be added to each task description. Getting started with the planning feature is very easy, the only step required is to add   to your Crew: From this point on, your crew will have planning enabled, and the tasks will be planned before each iteration. Now you can define the LLM that will be used to plan the tasks. When running the base case example, you will see something like the output below, which represents the output of the  \nresponsible for creating the step-by-step logic to add to the Agents\u2019 tasks. Was this page helpful?"},
{"url": "https://docs.crewai.com/guides/flows/first-flow", "title": "Build Your First Flow - CrewAI", "content": "Learn how to create structured, event-driven workflows with precise control over execution. CrewAI Flows represent the next level in AI orchestration - combining the collaborative power of AI agent crews with the precision and flexibility of procedural programming. While crews excel at agent collaboration, flows give you fine-grained control over exactly how and when different components of your AI system interact. In this guide, we\u2019ll walk through creating a powerful CrewAI Flow that generates a comprehensive learning guide on any topic. This tutorial will demonstrate how Flows provide structured, event-driven control over your AI workflows by combining regular code, direct LLM calls, and crew-based processing. Flows enable you to: By the end of this guide, you\u2019ll have: This guide creator flow demonstrates fundamental patterns that can be applied to create much more advanced applications, such as: Let\u2019s dive in and build your first flow! Before starting, make sure you have: First, let\u2019s create a new CrewAI Flow project using the CLI. This command sets up a scaffolded project with all the necessary directories and template files for your flow. This will generate a project with the basic structure needed for your flow. CrewAI Framework Overview The generated project has the following structure. Take a moment to familiarize yourself with it, as understanding this structure will help you create more complex flows in the future. This structure provides a clear separation between different components of your flow: We\u2019ll modify this structure to create our guide creator flow, which will orchestrate the process of generating comprehensive learning guides. Our flow will need a specialized crew to handle the content creation process. Let\u2019s use the CrewAI CLI to add a content writer crew: This command automatically creates the necessary directories and template files for your crew. The content writer crew will be responsible for writing and reviewing sections of our guide, working within the overall flow orchestrated by our main application. Now, let\u2019s modify the generated files for the content writer crew. We\u2019ll set up two specialized agents - a writer and a reviewer - that will collaborate to create high-quality content for our guide. These agent definitions establish the specialized roles and perspectives that will shape how our AI agents approach content creation. Notice how each agent has a distinct purpose and expertise. These task definitions provide detailed instructions to our agents, ensuring they produce content that meets our quality standards. Note how the   parameter in the review task creates a workflow where the reviewer has access to the writer\u2019s output. This crew definition establishes the relationship between our agents and tasks, setting up a sequential process where the content writer creates a draft and then the reviewer improves it. While this crew can function independently, in our flow it will be orchestrated as part of a larger system. Now comes the exciting part - creating the flow that will orchestrate the entire guide creation process. This is where we\u2019ll combine regular Python code, direct LLM calls, and our content creation crew into a cohesive system. Our flow will: Let\u2019s create our flow in the   file: Let\u2019s analyze what\u2019s happening in this flow: This is the power of flows - combining different types of processing (user interaction, direct LLM calls, crew-based tasks) into a coherent, event-driven system. Create a   file in your project root with your API keys: Install the required dependencies: Now it\u2019s time to see your flow in action! Run it using the CrewAI CLI: When you run this command, you\u2019ll see your flow spring to life: This demonstrates the power of flows to orchestrate complex processes involving multiple components, both AI and non-AI. One of the powerful features of flows is the ability to visualize their structure: This will create an HTML file that shows the structure of your flow, including the relationships between different steps and the data that flows between them. This visualization can be invaluable for understanding and debugging complex flows. Once the flow completes, you\u2019ll find two files in the   directory: Take a moment to review these files and appreciate what you\u2019ve built - a system that combines user input, direct AI interactions, and collaborative agent work to produce a complex, high-quality output. What you\u2019ve learned in this guide provides a foundation for creating much more sophisticated AI systems. Here are some ways you could extend this basic flow: You could create more interactive flows with: You could expand your flow with additional steps for: You could implement more sophisticated flow patterns: The same patterns can be applied to create flows for: This guide creator flow demonstrates several powerful features of CrewAI: Let\u2019s break down the key components of flows to help you understand how to build your own: Flows allow you to make direct calls to language models when you need simple, structured responses: This is more efficient than using a crew when you need a specific, structured output. Flows use decorators to establish relationships between components: This creates a clear, declarative structure for your application. Flows maintain state across steps, making it easy to share data: This provides a type-safe way to track and transform data throughout your flow. Flows can seamlessly integrate with crews for complex collaborative tasks: This allows you to use the right tool for each part of your application - direct LLM calls for simple tasks and crews for complex collaboration. Now that you\u2019ve built your first flow, you can: Congratulations! You\u2019ve successfully built your first CrewAI Flow that combines regular code, direct LLM calls, and crew-based processing to create a comprehensive guide. These foundational skills enable you to create increasingly sophisticated AI applications that can tackle complex, multi-stage problems through a combination of procedural control and collaborative intelligence. Was this page helpful?"},
{"url": "https://docs.crewai.com/guides/crews/first-crew", "title": "Build Your First Crew - CrewAI", "content": "Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems. Imagine having a team of specialized AI agents working together seamlessly to solve complex problems, each contributing their unique skills to achieve a common goal. This is the power of CrewAI - a framework that enables you to create collaborative AI systems that can accomplish tasks far beyond what a single AI could achieve alone. In this guide, we\u2019ll walk through creating a research crew that will help us research and analyze a topic, then create a comprehensive report. This practical example demonstrates how AI agents can collaborate to accomplish complex tasks, but it\u2019s just the beginning of what\u2019s possible with CrewAI. By the end of this guide, you\u2019ll have: While we\u2019re building a simple research crew in this guide, the same patterns and techniques can be applied to create much more sophisticated teams for tasks like: Let\u2019s get started building your first crew! Before starting, make sure you have: First, let\u2019s create a new CrewAI project using the CLI. This command will set up a complete project structure with all the necessary files, allowing you to focus on defining your agents and their tasks rather than setting up boilerplate code. This will generate a project with the basic structure needed for your crew. The CLI automatically creates: CrewAI Framework Overview Let\u2019s take a moment to understand the project structure created by the CLI. CrewAI follows best practices for Python projects, making it easy to maintain and extend your code as your crews become more complex. This structure follows best practices for Python projects and makes it easy to organize your code. The separation of configuration files (in YAML) from implementation code (in Python) makes it easy to modify your crew\u2019s behavior without changing the underlying code. Now comes the fun part - defining your AI agents! In CrewAI, agents are specialized entities with specific roles, goals, and backstories that shape their behavior. Think of them as characters in a play, each with their own personality and purpose. For our research crew, we\u2019ll create two agents: Let\u2019s modify the   file to define these specialized agents: Notice how each agent has a distinct role, goal, and backstory. These elements aren\u2019t just descriptive - they actively shape how the agent approaches its tasks. By crafting these carefully, you can create agents with specialized skills and perspectives that complement each other. With our agents defined, we now need to give them specific tasks to perform. Tasks in CrewAI represent the concrete work that agents will perform, with detailed instructions and expected outputs. For our research crew, we\u2019ll define two main tasks: Let\u2019s modify the   file: Note the   field in the analysis task - this is a powerful feature that allows the analyst to access the output of the research task. This creates a workflow where information flows naturally between agents, just as it would in a human team. Now it\u2019s time to bring everything together by configuring our crew. The crew is the container that orchestrates how agents work together to complete tasks. Let\u2019s modify the   file: In this code, we\u2019re: This is where the magic happens - with just a few lines of code, we\u2019ve defined a collaborative AI system where specialized agents work together in a coordinated process. Now, let\u2019s set up the main script that will run our crew. This is where we provide the specific topic we want our crew to research. This script prepares the environment, specifies our research topic, and kicks off the crew\u2019s work. The power of CrewAI is evident in how simple this code is - all the complexity of managing multiple AI agents is handled by the framework. Create a   file in your project root with your API keys: You can get a Serper API key from  . Install the required dependencies using the CrewAI CLI: This command will: Now for the exciting moment - it\u2019s time to run your crew and see AI collaboration in action! When you run this command, you\u2019ll see your crew spring to life. The researcher will gather information about the specified topic, and the analyst will then create a comprehensive report based on that research. You\u2019ll see the agents\u2019 thought processes, actions, and outputs in real-time as they work together to complete their tasks. Once the crew completes its work, you\u2019ll find the final report in the   file. The report will include: Take a moment to appreciate what you\u2019ve accomplished - you\u2019ve created a system where multiple AI agents collaborated on a complex task, each contributing their specialized skills to produce a result that\u2019s greater than what any single agent could achieve alone. CrewAI offers several other useful CLI commands for working with crews: What you\u2019ve built in this guide is just the beginning. The skills and patterns you\u2019ve learned can be applied to create increasingly sophisticated AI systems. Here are some ways you could extend this basic research crew: You could add more specialized agents to your crew: You could enhance your agents with additional tools: You could implement more sophisticated processes: The same patterns can be applied to create crews for: Now that you\u2019ve built your first crew, you can: Congratulations! You\u2019ve successfully built your first CrewAI crew that can research and analyze any topic you provide. This foundational experience has equipped you with the skills to create increasingly sophisticated AI systems that can tackle complex, multi-stage problems through collaborative intelligence. Was this page helpful?"},
{"url": "https://docs.crewai.com/telemetry", "title": "Telemetry - CrewAI", "content": "Understanding the telemetry data collected by CrewAI and how it contributes to the enhancement of the library. By default, we collect no data that would be considered personal information under GDPR and other privacy regulations.\nWe do collect Tool\u2019s names and Agent\u2019s roles, so be advised not to include any personal information in the tool\u2019s names or the Agent\u2019s roles.\nBecause no personal information is collected, it\u2019s not necessary to worry about data residency.\nWhen   is enabled, additional data is collected which may contain personal information if included by the user.\nUsers should exercise caution when enabling this feature to ensure compliance with privacy regulations. CrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library.\nOur focus is on improving and developing the features, integrations, and tools most utilized by our users. It\u2019s pivotal to understand that by default,   concerning prompts, task descriptions, agents\u2019 backstories or goals,\nusage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables.\nWhen the   feature is enabled, detailed data including task descriptions, agents\u2019 backstories or goals, and other specific attributes are collected\nto provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks.\nUsers should carefully consider the content of their crews and tasks before enabling  .\nUsers can disable telemetry by setting the environment variable   to  . \u201cNo\u201d in the \u201cDefaulted\u201d column indicates that this data is only collected when   is set to  . Users can choose to share their complete telemetry data by enabling the   attribute to   in their crew configurations.\nEnabling   results in the collection of detailed crew and task execution data, including  ,  ,  , and   of tasks.\nThis enables a deeper insight into usage patterns. If you enable  , the collected data may include personal information if it has been incorporated into crew configurations, task descriptions, or outputs.\nUsers should carefully review their data and ensure compliance with GDPR and other applicable privacy regulations before enabling this feature. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/youtubevideosearchtool", "title": "YouTube Video RAG Search - CrewAI", "content": "The   is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube video. We are still working on improving tools, so there might be unexpected behavior or changes in the future. This tool is part of the   package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques.\nIt is one of several \u201cSearch\u201d tools in the package that leverage RAG for different sources.\nThe YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL,\nor they can target their search to a specific Youtube video by providing its URL. To utilize the  , you must first install the   package.\nThis package contains the   among other utilities designed to enhance your data analysis and processing tasks.\nInstall the package by executing the following command in your terminal: The following example demonstrates how to use the   with a CrewAI agent: You can also initialize the tool with a specific YouTube video URL: The   accepts the following parameters: When using the tool with an agent, the agent will need to provide: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Here\u2019s a more detailed example of how to integrate the   with a CrewAI agent: The   is implemented as a subclass of  , which provides the base functionality for Retrieval-Augmented Generation: The   provides a powerful way to search and extract information from YouTube video content using RAG techniques. By enabling agents to search within video content, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from video sources. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/youtubechannelsearchtool", "title": "YouTube Channel RAG Search - CrewAI", "content": "The   is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube channel. We are still working on improving tools, so there might be unexpected behavior or changes in the future. This tool is designed to perform semantic searches within a specific Youtube channel\u2019s content.\nLeveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results,\nmaking it invaluable for extracting information or finding specific content without the need to manually sift through videos.\nIt streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics. To utilize the YoutubeChannelSearchTool, the   package must be installed. Execute the following command in your shell to install: The following example demonstrates how to use the   with a CrewAI agent: You can also initialize the tool with a specific YouTube channel handle: The   accepts the following parameters: When using the tool with an agent, the agent will need to provide: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Here\u2019s a more detailed example of how to integrate the   with a CrewAI agent: The   is implemented as a subclass of  , which provides the base functionality for Retrieval-Augmented Generation: The   provides a powerful way to search and extract information from YouTube channel content using RAG techniques. By enabling agents to search across an entire channel\u2019s videos, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from YouTube channels. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/xmlsearchtool", "title": "XML RAG Search - CrewAI", "content": "The   is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a XML file. We are still working on improving tools, so there might be unexpected behavior or changes in the future. The XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files.\nIdeal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path.\nBy specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes. To start using the XMLSearchTool, you must first install the crewai_tools package. This can be easily done with the following command: Here are two examples demonstrating how to use the XMLSearchTool.\nThe first example shows searching within a specific XML file, while the second example illustrates initiating a search without predefining an XML path, providing flexibility in search scope. By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/websitesearchtool", "title": "Website RAG Search - CrewAI", "content": "The   is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a website. The WebsiteSearchTool is currently in an experimental phase. We are actively working on incorporating this tool into our suite of offerings and will update the documentation accordingly. The WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites.\nIt aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently.\nThis tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest.\nPlease note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible. To prepare your environment for when the WebsiteSearchTool becomes available, you can install the foundational package with: This command installs the necessary dependencies to ensure that once the tool is fully integrated, users can start using it immediately. Below are examples of how the WebsiteSearchTool could be utilized in different scenarios. Please note, these examples are illustrative and represent planned functionality: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/weaviatevectorsearchtool", "title": "Weaviate Vector Search - CrewAI", "content": "The   is designed to search a Weaviate vector database for semantically similar documents. The   is specifically crafted for conducting semantic searches within documents stored in a Weaviate vector database. This tool allows you to find semantically similar documents to a given query, leveraging the power of vector embeddings for more accurate and contextually relevant search results.  is a vector database that stores and queries vector embeddings, enabling semantic search capabilities. To incorporate this tool into your project, you need to install the Weaviate client: To effectively use the  , follow these steps: The following example demonstrates how to initialize the tool and execute a search: The   accepts the following parameters: You can customize the vectorizer and generative model used by the tool: You can preload your Weaviate database with documents before using the tool: Here\u2019s how to integrate the   with a CrewAI agent: The   provides a powerful way to search for semantically similar documents in a Weaviate vector database. By leveraging vector embeddings, it enables more accurate and contextually relevant search results compared to traditional keyword-based searches. This tool is particularly useful for applications that require finding information based on meaning rather than exact matches. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/visiontool", "title": "Vision Tool - CrewAI", "content": "The   is designed to extract text from images. This tool is used to extract text from images. When passed to the agent it will extract the text from the image and then use it to generate a response, report or any other output.\nThe URL or the PATH of the image should be passed to the Agent. Install the crewai_tools package In order to use the VisionTool, the OpenAI API key should be set in the environment variable  . The VisionTool requires the following arguments: Was this page helpful?"},
{"url": "https://docs.crewai.com/guides/flows/mastering-flow-state", "title": "Mastering Flow State Management - CrewAI", "content": "A comprehensive guide to managing, persisting, and leveraging state in CrewAI Flows for building robust AI applications. State management is the backbone of any sophisticated AI workflow. In CrewAI Flows, the state system allows you to maintain context, share data between steps, and build complex application logic. Mastering state management is essential for creating reliable, maintainable, and powerful AI applications. This guide will walk you through everything you need to know about managing state in CrewAI Flows, from basic concepts to advanced techniques, with practical code examples along the way. Effective state management enables you to: Let\u2019s explore how to leverage these capabilities effectively. In CrewAI Flows, the state follows a predictable lifecycle: Understanding this lifecycle is crucial for designing effective flows. CrewAI offers two ways to manage state in your flows: Let\u2019s examine each approach in detail. Unstructured state uses a dictionary-like approach, offering flexibility and simplicity for straightforward applications. With unstructured state: Here\u2019s a simple example of unstructured state management: Unstructured state is ideal for: While flexible, unstructured state lacks type checking and schema validation, which can lead to errors in complex applications. Structured state uses Pydantic models to define a schema for your flow\u2019s state, providing type safety, validation, and better developer experience. With structured state: Here\u2019s how to implement structured state management: Using structured state provides several advantages: Structured state is recommended for: Both unstructured and structured states automatically receive a unique identifier (UUID) to help track and manage state instances. This UUID is particularly valuable when implementing persistence or tracking multiple flow executions. Regardless of whether you\u2019re using structured or unstructured state, you can update state dynamically throughout your flow\u2019s execution. Flow methods can return values that are then passed as arguments to listening methods: This pattern allows you to combine direct data passing with state updates for maximum flexibility. One of CrewAI\u2019s most powerful features is the ability to persist flow state across executions. This enables workflows that can be paused, resumed, and even recovered after failures. The   decorator automates state persistence, saving your flow\u2019s state at key points in execution. When applied at the class level,   saves state after every method execution: For more granular control, you can apply   to specific methods: You can use state to implement complex conditional logic in your flows: For complex state transformations, you can create dedicated methods: This pattern of creating helper methods keeps your flow methods clean while enabling complex state manipulations. One of the most powerful patterns in CrewAI is combining flow state management with crew execution. You can use flow state to parameterize crews: When a crew completes, you can process its output and store it in your flow state: Design your state to contain only what\u2019s necessary: As your flows grow in complexity, structured state becomes increasingly valuable: For complex flows, document how state changes throughout the execution: Implement error handling for state access: Leverage state to track progress in long-running flows: Especially with structured state, prefer immutable operations for clarity: When developing, add logging to track state changes: You can add methods to visualize your state for debugging: Mastering state management in CrewAI Flows gives you the power to build sophisticated, robust AI applications that maintain context, make complex decisions, and deliver consistent results. Whether you choose unstructured or structured state, implementing proper state management practices will help you create flows that are maintainable, extensible, and effective at solving real-world problems. As you develop more complex flows, remember that good state management is about finding the right balance between flexibility and structure, making your code both powerful and easy to understand. You\u2019ve now mastered the concepts and practices of state management in CrewAI Flows! With this knowledge, you can create robust AI workflows that effectively maintain context, share data between steps, and build sophisticated application logic. Was this page helpful?"},
{"url": "https://docs.crewai.com/guides/agents/crafting-effective-agents", "title": "Crafting Effective Agents - CrewAI", "content": "Learn best practices for designing powerful, specialized AI agents that collaborate effectively to solve complex problems. At the heart of CrewAI lies the agent - a specialized AI entity designed to perform specific roles within a collaborative framework. While creating basic agents is simple, crafting truly effective agents that produce exceptional results requires understanding key design principles and best practices. This guide will help you master the art of agent design, enabling you to create specialized AI personas that collaborate effectively, think critically, and produce high-quality outputs tailored to your specific needs. The way you define your agents significantly impacts: Let\u2019s explore best practices for creating agents that excel in these dimensions. When building effective AI systems, remember this crucial principle:  . Why? Because even the most perfectly defined agent will fail with poorly designed tasks, but well-designed tasks can elevate even a simple agent. This means: This doesn\u2019t mean agent design isn\u2019t important - it absolutely is. But task design is where most execution failures occur, so prioritize accordingly. The most powerful agents in CrewAI are built on a strong foundation of three key elements: The role defines what the agent does and their area of expertise. When crafting roles: The goal directs the agent\u2019s efforts and shapes their decision-making process. Effective goals should: The backstory gives depth to the agent, influencing how they approach problems and interact with others. Good backstories: Agents perform significantly better when given specialized roles rather than general ones. A highly focused agent delivers more precise, relevant outputs: Effective agents strike the right balance between specialization (doing one thing extremely well) and versatility (being adaptable to various situations): The expertise level you assign to your agent shapes how they approach tasks: Choose the appropriate expertise level based on task complexity and quality requirements. For most collaborative crews, a mix of expertise levels often works best, with higher expertise assigned to core specialized functions. Let\u2019s look at some examples of agent definitions before and after applying these best practices: While agent design is important, task design is critical for successful execution. Here are best practices for designing tasks that set your agents up for success: A well-designed task has two key components that serve different purposes: The description should focus on what to do and how to do it, including: The expected output should define what the final result should look like: Tasks perform best when focused on one clear objective: Always clearly specify what inputs the task will use and what the output should look like: Explain why the task matters and how it fits into the larger workflow: For machine-readable outputs, specify the format clearly: Based on lessons learned from real-world implementations, here are the most common pitfalls in agent and task design:  Tasks lack sufficient detail, making it difficult for agents to execute effectively.  Tasks that combine multiple complex operations into one instruction set. \nBreak this into sequential, focused tasks:  The task description asks for one thing while the expected output specifies something different.  Asking agents to execute tasks that you yourself don\u2019t fully understand.  Creating unnecessarily complex agent hierarchies where sequential processes would work better.  Start with sequential processes and only move to hierarchical models when the workflow complexity truly requires it.  Generic agent definitions lead to generic outputs. When creating agents that will work together in a crew, consider: For example, a content creation crew might include: Some agents can be designed specifically to leverage certain tools effectively: Different LLMs have different strengths. Design your agents with these capabilities in mind: Agent design is often an iterative process. Here\u2019s a practical approach: Crafting effective agents is both an art and a science. By carefully defining roles, goals, and backstories that align with your specific needs, and combining them with well-designed tasks, you can create specialized AI collaborators that produce exceptional results. Remember that agent and task design is an iterative process. Start with these best practices, observe your agents in action, and refine your approach based on what you learn. And always keep in mind the 80/20 rule - focus most of your effort on creating clear, focused tasks to get the best results from your agents. Congratulations! You now understand the principles and practices of effective agent design. Apply these techniques to create powerful, specialized agents that work together seamlessly to accomplish complex tasks. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/txtsearchtool", "title": "TXT RAG Search - CrewAI", "content": "The   is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file. We are still working on improving tools, so there might be unexpected behavior or changes in the future. This tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.\nIt allows for semantic searching of a query within a specified text file\u2019s content,\nmaking it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided. To use the  , you first need to install the   package.\nThis can be done using pip, a package manager for Python.\nOpen your terminal or command prompt and enter the following command: This command will download and install the TXTSearchTool along with any necessary dependencies. The following example demonstrates how to use the TXTSearchTool to search within a text file.\nThis example shows both the initialization of the tool with a specific text file and the subsequent search within that file\u2019s content. By default, the tool uses OpenAI for both embeddings and summarization.\nTo customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/spidertool", "title": "Spider Scraper - CrewAI", "content": "The   is designed to extract and read the content of a specified website using Spider.  is the  \nopen source scraper and crawler that returns LLM-ready data.\nIt converts any website into pure HTML, markdown, metadata or text while enabling you to crawl with custom actions using AI. To use the   you need to download the  \nand the   SDK too: This example shows you how you can use the   to enable your agent to scrape and crawl websites.\nThe data returned from the Spider API is already LLM-ready, so no need to do any cleaning there. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/snowflakesearchtool", "title": "Snowflake Search Tool - CrewAI", "content": "The   enables CrewAI agents to execute SQL queries and perform semantic search on Snowflake data warehouses. The   is designed to connect to Snowflake data warehouses and execute SQL queries with advanced features like connection pooling, retry logic, and asynchronous execution. This tool allows CrewAI agents to interact with Snowflake databases, making it ideal for data analysis, reporting, and business intelligence tasks that require access to enterprise data stored in Snowflake. To use this tool, you need to install the required dependencies: Or alternatively: To effectively use the  , follow these steps: The following example demonstrates how to use the   to query data from a Snowflake database: You can also customize the tool with additional parameters: The   class accepts the following parameters: *Either   or   must be provided. The   accepts the following parameters during initialization: When using the  , you need to provide the following parameters: The tool will return the query results as a list of dictionaries, where each dictionary represents a row with column names as keys. The   implements connection pooling to improve performance by reusing database connections. You can control the pool size with the   parameter. The tool automatically retries failed queries with exponential backoff. You can configure the retry behavior with the   and   parameters. To improve performance for repeated queries, the tool can cache query results. This feature is enabled by default but can be disabled by setting  . In addition to password authentication, the tool supports key-pair authentication for enhanced security: The   includes comprehensive error handling for common Snowflake issues: When an error occurs, the tool will attempt to retry the operation (if configured) and provide detailed error information. The   provides a powerful way to integrate Snowflake data warehouses with CrewAI agents. With features like connection pooling, automatic retries, and query caching, it enables efficient and reliable access to enterprise data. This tool is particularly useful for data analysis, reporting, and business intelligence tasks that require access to structured data stored in Snowflake. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/seleniumscrapingtool", "title": "Selenium Scraper - CrewAI", "content": "The   is designed to extract and read the content of a specified website using Selenium. This tool is currently in development. As we refine its capabilities, users may encounter unexpected behavior.\nYour feedback is invaluable to us for making improvements. The   is crafted for high-efficiency web scraping tasks.\nIt allows for precise extraction of content from web pages by using CSS selectors to target specific elements.\nIts design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL. To use this tool, you need to install the CrewAI tools package and Selenium: You\u2019ll also need to have Chrome installed on your system, as the tool uses Chrome WebDriver for browser automation. The following example demonstrates how to use the   with a CrewAI agent: You can also initialize the tool with predefined parameters: The   accepts the following parameters during initialization: When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): Here\u2019s a more detailed example of how to integrate the   with a CrewAI agent: The   uses Selenium WebDriver to automate browser interactions: The tool performs the following steps: The   is particularly useful for scraping websites with dynamic content that is loaded via JavaScript. By using a real browser instance, it can: You can adjust the   parameter to ensure that all dynamic content has loaded before extraction. The   provides a powerful way to extract content from websites using browser automation. By enabling agents to interact with websites as a real user would, it facilitates scraping of dynamic content that would be difficult or impossible to extract using simpler methods. This tool is particularly useful for research, data collection, and monitoring tasks that involve modern web applications with JavaScript-rendered content. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/scrapflyscrapetool", "title": "Scrapfly Scrape Website Tool - CrewAI", "content": "The   leverages Scrapfly\u2019s web scraping API to extract content from websites in various formats. The   is designed to leverage  \u2019s web scraping API to extract content from websites. This tool provides advanced web scraping capabilities with headless browser support, proxies, and anti-bot bypass features. It allows for extracting web page data in various formats, including raw HTML, markdown, and plain text, making it ideal for a wide range of web scraping tasks. To use this tool, you need to install the Scrapfly SDK: You\u2019ll also need to obtain a Scrapfly API key by registering at  . To effectively use the  , follow these steps: The following example demonstrates how to use the   to extract content from a website: You can also customize the scraping parameters: The   accepts the following parameters: The   parameter allows you to customize the scraping behavior with the following options: For a complete list of configuration options, refer to the  . When using the   with an agent, the agent will need to provide the URL of the website to scrape and can optionally specify the format and additional configuration options: For more advanced usage with custom configuration: By default, the   will raise an exception if scraping fails. Agents can be instructed to handle failures gracefully by specifying the   parameter: The   uses the Scrapfly SDK to interact with the Scrapfly API: The   provides a powerful way to extract content from websites using Scrapfly\u2019s advanced web scraping capabilities. With features like headless browser support, proxies, and anti-bot bypass, it can handle complex websites and extract content in various formats. This tool is particularly useful for data extraction, content monitoring, and research tasks where reliable web scraping is required. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/scrapewebsitetool", "title": "Scrape Website - CrewAI", "content": "The   is designed to extract and read the content of a specified website. We are still working on improving tools, so there might be unexpected behavior or changes in the future. A tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content.\nThis tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites. Install the crewai_tools package Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/ragtool", "title": "RAG Tool - CrewAI", "content": "The   is a dynamic knowledge base tool for answering questions using Retrieval-Augmented Generation. The   is designed to answer questions by leveraging the power of Retrieval-Augmented Generation (RAG) through EmbedChain.\nIt provides a dynamic knowledge base that can be queried to retrieve relevant information from various data sources.\nThis tool is particularly useful for applications that require access to a vast array of information and need to provide contextually relevant answers. The following example demonstrates how to initialize the tool and use it with different data sources: The   can be used with a wide variety of data sources, including: The   accepts the following parameters: You can add content to the knowledge base using the   method: Here\u2019s how to integrate the   with a CrewAI agent: You can customize the behavior of the   by providing a configuration dictionary: The   provides a powerful way to create and query knowledge bases from various data sources. By leveraging Retrieval-Augmented Generation, it enables agents to access and retrieve relevant information efficiently, enhancing their ability to provide accurate and contextually appropriate responses. Was this page helpful?"},
{"url": "https://docs.crewai.com/guides/concepts/evaluating-use-cases", "title": "Evaluating Use Cases for CrewAI - CrewAI", "content": "Learn how to assess your AI application needs and choose the right approach between Crews and Flows based on complexity and precision requirements. When building AI applications with CrewAI, one of the most important decisions you\u2019ll make is choosing the right approach for your specific use case. Should you use a Crew? A Flow? A combination of both? This guide will help you evaluate your requirements and make informed architectural decisions. At the heart of this decision is understanding the relationship between   and   in your application: Complexity vs. Precision Matrix for CrewAI Applications This matrix helps visualize how different approaches align with varying requirements for complexity and precision. Let\u2019s explore what each quadrant means and how it guides your architectural choices. In the context of CrewAI applications,   refers to:  in this context refers to:  Simple Crews with minimal agents  Flows with direct LLM calls or simple Crews with structured outputs  Complex Crews with multiple specialized agents  Flows orchestrating multiple Crews with validation steps Crews are ideal when: Flows are ideal when: The most sophisticated applications often benefit from combining Crews and Flows: To determine the right approach for your specific use case, follow this step-by-step evaluation framework: Rate your application\u2019s complexity on a scale of 1-10 by considering: : How many distinct operations are required? : How interconnected are the different parts? : How much branching and decision-making is needed? : How specialized is the knowledge required? Calculate your average score to determine overall complexity. Rate your precision requirements on a scale of 1-10 by considering: : How structured must the output be? : How important is factual accuracy? : How consistent must results be across runs? : What is the impact of errors? Calculate your average score to determine overall precision requirements. Plot your complexity and precision scores on the matrix: Beyond complexity and precision, consider: Choosing between Crews and Flows\u2014or combining them\u2014is a critical architectural decision that impacts the effectiveness, maintainability, and scalability of your CrewAI application. By evaluating your use case along the dimensions of complexity and precision, you can make informed decisions that align with your specific requirements. Remember that the best approach often evolves as your application matures. Start with the simplest solution that meets your needs, and be prepared to refine your architecture as you gain experience and your requirements become clearer. You now have a framework for evaluating CrewAI use cases and choosing the right approach based on complexity and precision requirements. This will help you build more effective, maintainable, and scalable AI applications. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/qdrantvectorsearchtool", "title": "Qdrant Vector Search Tool - CrewAI", "content": "Semantic search capabilities for CrewAI agents using Qdrant vector database The Qdrant Vector Search Tool enables semantic search capabilities in your CrewAI agents by leveraging  , a vector similarity search engine. This tool allows your agents to search through documents stored in a Qdrant collection using semantic similarity. Install the required packages: Here\u2019s a minimal example of how to use the tool: Here\u2019s a complete example showing how to: The tool accepts these parameters in its schema: The tool returns results in JSON format: By default, the tool uses OpenAI\u2019s   model for vectorization. This requires: Instead of using the default embedding model, you might want to use your own embedding function in cases where you: Here\u2019s an example using a HuggingFace model: The tool handles these specific errors: Required environment variables: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/pgsearchtool", "title": "PG RAG Search - CrewAI", "content": "The   is designed to search PostgreSQL databases and return the most relevant results. The PGSearchTool is currently under development. This document outlines the intended functionality and interface.\nAs development progresses, please be aware that some features may not be available or could change. The PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology,\nit aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases.\nThe tool\u2019s goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on\nextensive datasets within a PostgreSQL environment. The   package, which will include the PGSearchTool upon its release, can be installed using the following command: The PGSearchTool is not yet available in the current version of the   package. This installation command will be updated once the tool is released. Below is a proposed example showcasing how to use the PGSearchTool for conducting a semantic search on a table within a PostgreSQL database: The PGSearchTool is designed to require the following arguments for its operation: The tool intends to use OpenAI for both embeddings and summarization by default. Users will have the option to customize the model using a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/pdfsearchtool", "title": "PDF RAG Search - CrewAI", "content": "The   is designed to search PDF files and return the most relevant results. We are still working on improving tools, so there might be unexpected behavior or changes in the future. The PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently.\nThis capability makes it especially useful for extracting specific information from large PDF files quickly. To get started with the PDFSearchTool, first, ensure the crewai_tools package is installed with the following command: Here\u2019s how to use the PDFSearchTool to search within a PDF document: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/patronustools", "title": "Patronus Evaluation Tools - CrewAI", "content": "The Patronus evaluation tools enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform. The   are designed to enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform. These tools provide different levels of control over the evaluation process, from allowing agents to select the most appropriate evaluator and criteria to using predefined criteria or custom local evaluators. There are three main Patronus evaluation tools: To use these tools, you need to install the Patronus package: You\u2019ll also need to set up your Patronus API key as an environment variable: To effectively use the Patronus evaluation tools, follow these steps: The following example demonstrates how to use the  , which allows agents to select the most appropriate evaluator and criteria: The following example demonstrates how to use the  , which uses predefined evaluator and criteria: The following example demonstrates how to use the  , which uses custom function evaluators: The   does not require any parameters during initialization. It automatically fetches available evaluators and criteria from the Patronus API. The   accepts the following parameters during initialization: The   accepts the following parameters during initialization: When using the Patronus evaluation tools, you provide the model input, output, and context, and the tool returns the evaluation results from the Patronus API. For the   and  , the following parameters are required when calling the tool: For the  , the same parameters are required, but the evaluator and gold answer are specified during initialization. The Patronus evaluation tools provide a powerful way to evaluate and score model inputs and outputs using the Patronus AI platform. By enabling agents to evaluate their own outputs or the outputs of other agents, these tools can help improve the quality and reliability of CrewAI workflows. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/nl2sqltool", "title": "NL2SQL Tool - CrewAI", "content": "The   is designed to convert natural language to SQL queries. This tool is used to convert natural language to SQL queries. When passsed to the agent it will generate queries and then use them to interact with the database. This enables multiple workflows like having an Agent to access the database fetch information based on the goal and then use the information to generate a response, report or any other output.\nAlong with that proivdes the ability for the Agent to update the database based on its goal. : Make sure that the Agent has access to a Read-Replica or that is okay for the Agent to run insert/update queries on the database. Install the crewai_tools package In order to use the NL2SQLTool, you need to pass the database URI to the tool. The URI should be in the format  . The primary task goal was: \u201cRetrieve the average, maximum, and minimum monthly revenue for each city, but only include cities that have more than one user. Also, count the number of user in each city and\nsort the results by the average monthly revenue in descending order\u201d So the Agent tried to get information from the DB, the first one is wrong so the Agent tries again and gets the correct information and passes to the next agent. \n The second task goal was: \u201cReview the data and create a detailed report, and then create the table on the database with the fields based on the data provided.\nInclude information on the average, maximum, and minimum monthly revenue for each city, but only include cities that have more than one user. Also, count the number of users in each city and sort the results by the average monthly revenue in descending order.\u201d Now things start to get interesting, the Agent generates the SQL query to not only create the table but also insert the data into the table. And in the end the Agent still returns the final report which is exactly what was in the database. \n \n This is a simple example of how the NL2SQLTool can be used to interact with the database and generate reports based on the data in the database. The Tool provides endless possibilities on the logic of the Agent and how it can interact with the database. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/multiontool", "title": "MultiOn Tool - CrewAI", "content": "The   empowers CrewAI agents with the capability to navigate and interact with the web through natural language instructions. The   is designed to wrap   web browsing capabilities, enabling CrewAI agents to control web browsers using natural language instructions. This tool facilitates seamless web browsing, making it an essential asset for projects requiring dynamic web data interaction and automation of web-based tasks. To use this tool, you need to install the MultiOn package: You\u2019ll also need to install the MultiOn browser extension and enable API usage. To effectively use the  , follow these steps: The following example demonstrates how to initialize the tool and execute a web browsing task: The   accepts the following parameters during initialization: When using the  , the agent will provide natural language instructions that the tool translates into web browsing actions. The tool returns the results of the browsing session along with a status. If the status returned is  , the agent should be instructed to reissue the same instruction to continue execution. The   is implemented as a subclass of   from CrewAI. It wraps the MultiOn client to provide web browsing capabilities: The   provides a powerful way to integrate web browsing capabilities into CrewAI agents. By enabling agents to interact with websites through natural language instructions, it opens up a wide range of possibilities for web-based tasks, from data collection and research to automated interactions with web services. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/mysqltool", "title": "MySQL RAG Search - CrewAI", "content": "The   is designed to search MySQL databases and return the most relevant results. This tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology,\nthe MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases.\nIt simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing\nto perform advanced queries on extensive datasets within a MySQL database. To install the   package and utilize the MySQLSearchTool, execute the following command in your terminal: Below is an example showcasing how to use the MySQLSearchTool to conduct a semantic search on a table within a MySQL database: The MySQLSearchTool requires the following arguments for its operation: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/mdxsearchtool", "title": "MDX RAG Search - CrewAI", "content": "The   is designed to search MDX files and return the most relevant results. The MDXSearchTool is in continuous development. Features may be added or removed, and functionality could change unpredictably as we refine the tool. The MDX Search Tool is a component of the   package aimed at facilitating advanced markdown language extraction. It enables users to effectively search and extract relevant information from MD files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections. Before using the MDX Search Tool, ensure the   package is installed. If it is not, you can install it with the following command: To use the MDX Search Tool, you must first set up the necessary environment variables. Then, integrate the tool into your crewAI project to begin your market research. Below is a basic example of how to do this: The tool defaults to using OpenAI for embeddings and summarization. For customization, utilize a configuration dictionary as shown below: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/jsonsearchtool", "title": "JSON RAG Search - CrewAI", "content": "The   is designed to search JSON files and return the most relevant results. The JSONSearchTool is currently in an experimental phase. This means the tool is under active development, and users might encounter unexpected behavior or changes.\nWe highly encourage feedback on any issues or suggestions for improvements. The JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results. To install the JSONSearchTool, use the following pip command: Here are updated examples on how to utilize the JSONSearchTool effectively for searching within JSON files. These examples take into account the current implementation and usage patterns identified in the codebase. The JSONSearchTool supports extensive customization through a configuration dictionary. This allows users to select different models for embeddings and summarization based on their requirements. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/scrapeelementfromwebsitetool", "title": "Scrape Element From Website Tool - CrewAI", "content": "The   enables CrewAI agents to extract specific elements from websites using CSS selectors. The   is designed to extract specific elements from websites using CSS selectors. This tool allows CrewAI agents to scrape targeted content from web pages, making it useful for data extraction tasks where only specific parts of a webpage are needed. To use this tool, you need to install the required dependencies: To effectively use the  , follow these steps: The following example demonstrates how to use the   to extract specific elements from a website: You can also initialize the tool with predefined parameters: The   accepts the following parameters during initialization: When using the   with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): The tool will return the text content of all elements matching the CSS selector, joined by newlines. The   uses the   library to fetch the web page and   to parse the HTML and extract the specified elements: The   provides a powerful way to extract specific elements from websites using CSS selectors. By enabling agents to target only the content they need, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/scrapegraphscrapetool", "title": "Scrapegraph Scrape Tool - CrewAI", "content": "The   leverages Scrapegraph AI\u2019s SmartScraper API to intelligently extract content from websites. The   is designed to leverage Scrapegraph AI\u2019s SmartScraper API to intelligently extract content from websites. This tool provides advanced web scraping capabilities with AI-powered content extraction, making it ideal for targeted data collection and content analysis tasks. Unlike traditional web scrapers, it can understand the context and structure of web pages to extract the most relevant information based on natural language prompts. To use this tool, you need to install the Scrapegraph Python client: You\u2019ll also need to set up your Scrapegraph API key as an environment variable: You can obtain an API key from  . To effectively use the  , follow these steps: The following example demonstrates how to use the   to extract content from a website: You can also initialize the tool with predefined parameters: The   accepts the following parameters during initialization: When using the   with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): The tool will return the extracted content based on the provided prompt. The   may raise the following exceptions: It\u2019s recommended to instruct agents to handle potential errors gracefully: The Scrapegraph API has rate limits that vary based on your subscription plan. Consider the following best practices: The   uses the Scrapegraph Python client to interact with the SmartScraper API: The   provides a powerful way to extract content from websites using AI-powered understanding of web page structure. By enabling agents to target specific information using natural language prompts, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/s3writertool", "title": "S3 Writer Tool - CrewAI", "content": "The   enables CrewAI agents to write content to files in Amazon S3 buckets. The   is designed to write content to files in Amazon S3 buckets. This tool allows CrewAI agents to create or update files in S3, making it ideal for workflows that require storing data, saving configuration files, or persisting any other content to AWS S3 storage. To use this tool, you need to install the required dependencies: To effectively use the  , follow these steps: The following example demonstrates how to use the   to write content to a file in an S3 bucket: The   accepts the following parameters when used by an agent: The tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: When using the   with an agent, the agent will need to provide both the S3 file path and the content to write: The   includes error handling for common S3 issues: When an error occurs, the tool will return an error message that includes details about the issue. The   uses the AWS SDK for Python (boto3) to interact with S3: The   provides a straightforward way to write content to files in Amazon S3 buckets. By enabling agents to create and update files in S3, it facilitates workflows that require cloud-based file storage. This tool is particularly useful for data persistence, configuration management, report generation, and any task that involves storing information in AWS S3 storage. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/s3readertool", "title": "S3 Reader Tool - CrewAI", "content": "The   enables CrewAI agents to read files from Amazon S3 buckets. The   is designed to read files from Amazon S3 buckets. This tool allows CrewAI agents to access and retrieve content stored in S3, making it ideal for workflows that require reading data, configuration files, or any other content stored in AWS S3 storage. To use this tool, you need to install the required dependencies: To effectively use the  , follow these steps: The following example demonstrates how to use the   to read a file from an S3 bucket: The   accepts the following parameter when used by an agent: The tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: When using the   with an agent, the agent will need to provide the S3 file path: The   includes error handling for common S3 issues: When an error occurs, the tool will return an error message that includes details about the issue. The   uses the AWS SDK for Python (boto3) to interact with S3: The   provides a straightforward way to read files from Amazon S3 buckets. By enabling agents to access content stored in S3, it facilitates workflows that require cloud-based file access. This tool is particularly useful for data processing, configuration management, and any task that involves retrieving information from AWS S3 storage. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/serperdevtool", "title": "Google Serper Search - CrewAI", "content": "The   is designed to search the internet and return the most relevant results. We are still working on improving tools, so there might be unexpected behavior or changes in the future. This tool is designed to perform a semantic search for a specified query from a text\u2019s content across the internet. It utilizes the   API\nto fetch and display the most relevant search results based on the query provided by the user. To incorporate this tool into your project, follow the installation instructions below: The following example demonstrates how to initialize the tool and execute a search with a given query: To effectively use the  , follow these steps: The   comes with several parameters that will be passed to the API : : The URL endpoint for the search API. (Default is  ) : Optional. Specify the country for the search results. : Optional. Specify the location for the search results. : Optional. Specify the locale for the search results. : Number of search results to return. Default is  . The values for  ,  ,   and   can be found on the  . Here is an example demonstrating how to use the tool with additional parameters: By integrating the   into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nThe updated parameters allow for more customized and localized search results. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/llamaindextool", "title": "LlamaIndex Tool - CrewAI", "content": "The   is a wrapper for LlamaIndex tools and query engines. The   is designed to be a general wrapper around LlamaIndex tools and query engines, enabling you to leverage LlamaIndex resources in terms of RAG/agentic pipelines as tools to plug into CrewAI agents. This tool allows you to seamlessly integrate LlamaIndex\u2019s powerful data processing and retrieval capabilities into your CrewAI workflows. To use this tool, you need to install LlamaIndex: To effectively use the  , follow these steps: The following examples demonstrate how to initialize the tool from different LlamaIndex components: The   provides two main class methods for creating instances: Creates a   from a LlamaIndex tool. Creates a   from a LlamaIndex query engine. The   method accepts the following parameters: The   provides a powerful way to integrate LlamaIndex\u2019s capabilities into CrewAI agents. By wrapping LlamaIndex tools and query engines, it enables agents to leverage sophisticated data retrieval and processing functionalities, enhancing their ability to work with complex information sources. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/linkupsearchtool", "title": "Linkup Search Tool - CrewAI", "content": "The   enables querying the Linkup API for contextual information. The   provides the ability to query the Linkup API for contextual information and retrieve structured results. This tool is ideal for enriching workflows with up-to-date and reliable information from Linkup, allowing agents to access relevant data during their tasks. To use this tool, you need to install the Linkup SDK: To effectively use the  , follow these steps: The following example demonstrates how to initialize the tool and use it in an agent: The   accepts the following parameters: You can customize the search parameters for more specific results: The tool returns results in the following format: If an error occurs, the response will be: The tool gracefully handles API errors and provides structured feedback. If the API request fails, the tool will return a dictionary with   and an error message. The   provides a seamless way to integrate Linkup\u2019s contextual information retrieval capabilities into your CrewAI agents. By leveraging this tool, agents can access relevant and up-to-date information to enhance their decision-making and task execution. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/hyperbrowserloadtool", "title": "Hyperbrowser Load Tool - CrewAI", "content": "The   enables web scraping and crawling using Hyperbrowser. The   enables web scraping and crawling using  , a platform for running and scaling headless browsers. This tool allows you to scrape a single page or crawl an entire site, returning the content in properly formatted markdown or HTML. Key Features: To use this tool, you need to install the Hyperbrowser SDK: To effectively use the  , follow these steps: The following example demonstrates how to initialize the tool and use it to scrape a website: The   accepts the following parameters: For detailed information on all supported parameters, visit: The tool returns content in the following format: The   provides a powerful way to scrape and crawl websites, handling complex scenarios like anti-bot measures, CAPTCHAs, and more. By leveraging Hyperbrowser\u2019s platform, this tool enables agents to access and extract web content efficiently. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/githubsearchtool", "title": "Github Search - CrewAI", "content": "The   is designed to search websites and convert them into clean markdown or structured data. We are still working on improving tools, so there might be unexpected behavior or changes in the future. The GithubSearchTool is a Retrieval-Augmented Generation (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub. To use the GithubSearchTool, first ensure the crewai_tools package is installed in your Python environment: This command installs the necessary package to run the GithubSearchTool along with any other tools included in the crewai_tools package. Here\u2019s how you can use the GithubSearchTool to perform semantic searches within a GitHub repository: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/firecrawlsearchtool", "title": "Firecrawl Search - CrewAI", "content": "The   is designed to search websites and convert them into clean markdown or structured data.  is a platform for crawling and convert any website into clean markdown or structured data. Utilize the FirecrawlSearchTool as follows to allow your agent to load websites: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/firecrawlscrapewebsitetool", "title": "Firecrawl Scrape Website - CrewAI", "content": "The   is designed to scrape websites and convert them into clean markdown or structured data.  is a platform for crawling and convert any website into clean markdown or structured data. Utilize the FirecrawlScrapeWebsiteTool as follows to allow your agent to load websites: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/firecrawlcrawlwebsitetool", "title": "Firecrawl Crawl Website - CrewAI", "content": "The   is designed to crawl and convert websites into clean markdown or structured data.  is a platform for crawling and convert any website into clean markdown or structured data. Utilize the FirecrawlScrapeFromWebsiteTool as follows to allow your agent to load websites: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/filewritetool", "title": "File Write - CrewAI", "content": "The   is designed to write content to files. The   is a component of the crewai_tools package, designed to simplify the process of writing content to files with cross-platform compatibility (Windows, Linux, macOS).\nIt is particularly useful in scenarios such as generating reports, saving logs, creating configuration files, and more.\nThis tool handles path differences across operating systems, supports UTF-8 encoding, and automatically creates directories if they don\u2019t exist, making it easier to organize your output reliably across different platforms. Install the crewai_tools package to use the   in your projects: To get started with the  : By integrating the   into your crews, the agents can reliably write content to files across different operating systems.\nThis tool is essential for tasks that require saving output data, creating structured file systems, and handling cross-platform file operations.\nIt\u2019s particularly recommended for Windows users who may encounter file writing issues with standard Python file operations. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is straightforward and ensures consistent file writing behavior across all platforms. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/filereadtool", "title": "File Read - CrewAI", "content": "The   is designed to read files from the local file system. We are still working on improving tools, so there might be unexpected behavior or changes in the future. The FileReadTool conceptually represents a suite of functionalities within the crewai_tools package aimed at facilitating file reading and content retrieval.\nThis suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics.\nIt supports a variety of text-based file formats such as  ,  ,  , and more. Depending on the file type, the suite offers specialized functionality,\nsuch as converting JSON content into a Python dictionary for ease of use. To utilize the functionalities previously attributed to the FileReadTool, install the crewai_tools package: To get started with the FileReadTool: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/exasearchtool", "title": "EXA Search Web Loader - CrewAI", "content": "The   is designed to perform a semantic search for a specified query from a text\u2019s content across the internet. The EXASearchTool is designed to perform a semantic search for a specified query from a text\u2019s content across the internet.\nIt utilizes the   API to fetch and display the most relevant search results based on the query provided by the user. To incorporate this tool into your project, follow the installation instructions below: The following example demonstrates how to initialize the tool and execute a search with a given query: To effectively use the EXASearchTool, follow these steps: Package Installation Confirm that the   package is installed in your Python environment. API Key Acquisition Acquire a   API key by registering for a free account at  . Environment Configuration Store your obtained API key in an environment variable named   to facilitate its use by the tool. By integrating the   into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nBy adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/docxsearchtool", "title": "DOCX RAG Search - CrewAI", "content": "The   is a RAG tool designed for semantic searching within DOCX documents. We are still working on improving tools, so there might be unexpected behavior or changes in the future. The   is a RAG tool designed for semantic searching within DOCX documents.\nIt enables users to effectively search and extract relevant information from DOCX files using query-based searches.\nThis tool is invaluable for data analysis, information management, and research tasks,\nstreamlining the process of finding specific information within large document collections. Install the crewai_tools package by running the following command in your terminal: The following example demonstrates initializing the DOCXSearchTool to search within any DOCX file\u2019s content or with a specific DOCX file path. The following parameters can be used to customize the  \u2019s behavior: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/directoryreadtool", "title": "Directory Read - CrewAI", "content": "The   is a powerful utility designed to provide a comprehensive listing of directory contents. We are still working on improving tools, so there might be unexpected behavior or changes in the future. The DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents.\nIt can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories.\nThis tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories. To utilize the DirectoryReadTool in your project, install the   package. If this package is not yet part of your environment, you can install it using pip with the command below: This command installs the latest version of the   package, granting access to the DirectoryReadTool among other utilities. Employing the DirectoryReadTool is straightforward. The following code snippet demonstrates how to set it up and use the tool to list the contents of a specified directory: The following parameters can be used to customize the  \u2019s behavior: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/directorysearchtool", "title": "Directory RAG Search - CrewAI", "content": "The   is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a directory\u2019s content. : The DirectorySearchTool is under continuous development. Features and functionalities might evolve, and unexpected behavior may occur as we refine the tool. The DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup. To use the DirectorySearchTool, begin by installing the crewai_tools package. Execute the following command in your terminal: Import the DirectorySearchTool from the   package to start. You can initialize the tool without specifying a directory, enabling the setting of the search directory at runtime. Alternatively, the tool can be initialized with a predefined directory. The DirectorySearchTool uses OpenAI for embeddings and summarization by default. Customization options for these settings include changing the model provider and configuration, enhancing flexibility for advanced users. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/dalletool", "title": "DALL-E Tool - CrewAI", "content": "The   is a powerful tool designed for generating images from textual descriptions. This tool is used to give the Agent the ability to generate images using the DALL-E model. It is a transformer-based model that generates images from textual descriptions.\nThis tool allows the Agent to generate images based on the text input provided by the user. Install the crewai_tools package Remember that when using this tool, the text must be generated by the Agent itself. The text must be a description of the image you want to generate. If needed you can also tweak the parameters of the DALL-E model by passing them as arguments to the   class. For example: The parameters are based on the   method from the OpenAI API. For more information on the parameters,\nplease refer to the  . Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/csvsearchtool", "title": "CSV RAG Search - CrewAI", "content": "The   is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a CSV file\u2019s content. : We are still working on improving tools, so there might be unexpected behavior or changes in the future. This tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file\u2019s content. It allows users to semantically search for queries in the content of a specified CSV file.\nThis feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \u201cSearch\u201d in their name, including CSVSearchTool,\nare RAG tools designed for searching different sources of data. Install the crewai_tools package The following parameters can be used to customize the  \u2019s behavior: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/composiotool", "title": "Composio Tool - CrewAI", "content": "Composio provides 250+ production-ready tools for AI agents with flexible authentication management. Composio is an integration platform that allows you to connect your AI agents to 250+ tools. Key features include: To incorporate Composio tools into your project, follow the instructions below: After the installation is complete, either run   or export your composio API key as  . Get your Composio API key from  The following example demonstrates how to initialize the tool and execute a github action: In this demo, we will use the   action from the GitHub app. Learn more about filtering actions  Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/codeinterpretertool", "title": "Code Interpreter - CrewAI", "content": "The   is a powerful tool designed for executing Python 3 code within a secure, isolated environment. The   enables CrewAI agents to execute Python 3 code that they generate autonomously. The code is run in a secure, isolated Docker container, ensuring safety regardless of the content. This functionality is particularly valuable as it allows agents to create code, execute it, obtain the results, and utilize that information to inform subsequent decisions and actions. To use this tool, you need to install the CrewAI tools package: The following example demonstrates how to use the   with a CrewAI agent: You can also enable code execution directly when creating an agent: The   accepts the following parameters during initialization: When using the tool with an agent, the agent will need to provide: Here\u2019s a more detailed example of how to integrate the   with a CrewAI agent: The   uses Docker to create a secure environment for code execution: The tool performs the following steps: By default, the   runs code in an isolated Docker container, which provides a layer of security. However, there are still some security considerations to keep in mind: The   provides a powerful way for CrewAI agents to execute Python code in a relatively secure environment. By enabling agents to write and run code, it significantly expands their problem-solving capabilities, especially for tasks involving data analysis, calculations, or other computational work. This tool is particularly useful for agents that need to perform complex operations that are more efficiently expressed in code than in natural language. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/codedocssearchtool", "title": "Code Docs RAG Search - CrewAI", "content": "The   is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation. : We are still working on improving tools, so there might be unexpected behavior or changes in the future. The CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.\nIt enables users to efficiently find specific information or topics within code documentation. By providing a   during initialization,\nthe tool narrows down the search to that particular documentation site. Alternatively, without a specific  ,\nit searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs. To start using the CodeDocsSearchTool, first, install the crewai_tools package via pip: Utilize the CodeDocsSearchTool as follows to conduct searches within code documentation: Substitute \u2018 \u2019 with your target documentation URL\nand \u2018How to use search tool\u2019 with the search query relevant to your needs. The following parameters can be used to customize the  \u2019s behavior: By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/browserbaseloadtool", "title": "Browserbase Web Loader - CrewAI", "content": "Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.  is a developer platform to reliably run, manage, and monitor headless browsers. Power your AI data retrievals with: Utilize the BrowserbaseLoadTool as follows to allow your agent to load websites: The following parameters can be used to customize the  \u2019s behavior: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/bravesearchtool", "title": "Brave Search - CrewAI", "content": "The   is designed to search the internet using the Brave Search API. This tool is designed to perform web searches using the Brave Search API. It allows you to search the internet with a specified query and retrieve relevant results. The tool supports customizable result counts and country-specific searches. To incorporate this tool into your project, follow the installation instructions below: To effectively use the  , follow these steps: The following example demonstrates how to initialize the tool and execute a search with a given query: The   accepts the following parameters: Here is an example demonstrating how to use the tool with additional parameters: Here\u2019s how to integrate the   with a CrewAI agent: By integrating the   into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. The tool provides a simple interface to the powerful Brave Search API, making it easy to retrieve and process search results programmatically. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward. Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/apifyactorstool", "title": "Apify Actors - CrewAI", "content": " lets you call Apify Actors to provide your CrewAI workflows with web scraping, crawling, data extraction, and web automation capabilities. Integrate   into your CrewAI workflows. The   connects  , cloud-based programs for web scraping and automation, to your CrewAI workflows.\nUse any of the 4,000+ Actors on   for use cases such as extracting data from social media, search engines, online maps, e-commerce sites, travel portals, or general websites. For details, see the   in Apify documentation. Install dependencies Install   and   using pip:  . Obtain an Apify API token Sign up to   and get your  .. Configure environment Set your Apify API token as the   environment variable to enable the tool\u2019s functionality. Use the   manually to run the   to perform a web search: Here is the output from running the code above: The   automatically fetches the Actor definition and input schema from Apify using the provided   and then constructs the tool description and argument schema. This means you need to specify only a valid  , and the tool handles the rest when used with agents\u2014no need to specify the  . Here\u2019s how it works: You can run other Actors from   simply by changing the   and, when using it manually, adjusting the   based on the Actor input schema. For an example of usage with agents, see the  . The   requires these inputs to work: Was this page helpful?"},
{"url": "https://docs.crewai.com/tools/aimindtool", "title": "AI Mind Tool - CrewAI", "content": "The   is designed to query data sources in natural language. The   is a wrapper around   provided by  . It allows you to query data sources in natural language by simply configuring their connection parameters. This tool is useful when you need answers to questions from your data stored in various data sources including PostgreSQL, MySQL, MariaDB, ClickHouse, Snowflake, and Google BigQuery. Minds are AI systems that work similarly to large language models (LLMs) but go beyond by answering any question from any data. This is accomplished by: To incorporate this tool into your project, you need to install the Minds SDK: To effectively use the  , follow these steps: The following example demonstrates how to initialize the tool and execute a query: The   accepts the following parameters: A list of supported data sources and their connection parameters can be found  . Here\u2019s how to integrate the   with a CrewAI agent: The   provides a powerful way to query your data sources using natural language, making it easier to extract insights without writing complex SQL queries. By connecting to various data sources and leveraging AI-Minds technology, this tool enables agents to access and analyze data efficiently. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/langfuse-observability", "title": "Agent Monitoring with Langfuse - CrewAI", "content": "Learn how to integrate Langfuse with CrewAI via OpenTelemetry using OpenLit This notebook demonstrates how to integrate   with   using OpenTelemetry via the   SDK. By the end of this notebook, you will be able to trace your CrewAI applications with Langfuse for improved observability and debugging.    is an open-source LLM engineering platform. It provides tracing and monitoring capabilities for LLM applications, helping developers debug, analyze, and optimize their AI systems. Langfuse integrates with various tools and frameworks via native integrations, OpenTelemetry, and APIs/SDKs. We\u2019ll walk through a simple example of using CrewAI and integrating it with Langfuse via OpenTelemetry using OpenLit. Set your Langfuse API keys and configure OpenTelemetry export settings to send traces to Langfuse. Please refer to the   for more information on the Langfuse OpenTelemetry endpoint   and authentication. Initialize the OpenLit OpenTelemetry instrumentation SDK to start capturing OpenTelemetry traces. We\u2019ll create a simple CrewAI application where multiple agents collaborate to answer a user\u2019s question. After running the agent, you can view the traces generated by your CrewAI application in  . You should see detailed steps of the LLM interactions, which can help you debug and optimize your AI agent. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/portkey-observability", "title": "Agent Monitoring with Portkey - CrewAI", "content": "How to use Portkey with CrewAI  is a 2-line upgrade to make your CrewAI agents reliable, cost-efficient, and fast. Portkey adds 4 core production capabilities to any CrewAI agent: Install CrewAI and Portkey Configure the LLM Client To build CrewAI Agents with Portkey, you\u2019ll need two keys: Create and Run Your First Agent All features mentioned below are through Portkey\u2019s Config system. Portkey\u2019s Config system allows you to define routing strategies using simple JSON objects in your LLM API calls. You can create and manage Configs directly in your code or through the Portkey Dashboard. Each Config has a unique ID for easy reference. Access various LLMs like Anthropic, Gemini, Mistral, Azure OpenAI, and more with minimal code changes. Switch between providers or use them together seamlessly.  Easily switch between different LLM providers: Improve response times and reduce costs with two powerful caching modes: Portkey provides comprehensive reliability features: Agent runs are complex. Portkey automatically logs   for your AI agents, including cost, tokens used, latency, etc. Whether you need a broad overview or granular insights into your agent runs, Portkey\u2019s customizable filters provide the metrics you need. Logs are essential for understanding agent behavior, diagnosing issues, and improving performance. They provide a detailed record of agent activities and tool use, which is crucial for debugging and optimizing processes. Access a dedicated section to view records of agent executions, including parameters, outcomes, function calls, and errors. Filter logs based on multiple parameters such as trace ID, model, tokens used, and metadata. For detailed information on creating and managing Configs, visit the  . Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/openlit-observability", "title": "Agent Monitoring with OpenLIT - CrewAI", "content": "Quickly start monitoring your Agents in just a single line of code with OpenTelemetry.  is an open-source tool that makes it simple to monitor the performance of AI agents, LLMs, VectorDBs, and GPUs with just   line of code. It provides OpenTelemetry-native tracing and metrics to track important parameters like cost, latency, interactions and task sequences.\nThis setup enables you to track hyperparameters and monitor for performance issues, helping you find ways to enhance and fine-tune your agents over time. OpenLIT Dashboard Deploy OpenLIT Git Clone OpenLIT Repository Start Docker Compose From the root directory of the  , Run the below command: Install OpenLIT SDK Initialize OpenLIT in Your Application Add the following two lines to your application code: Example Usage for monitoring a CrewAI Agent: Refer to OpenLIT   for more advanced configurations and use cases. Visualize and Analyze With the Agent Observability data now being collected and sent to OpenLIT, the next step is to visualize and analyze this data to get insights into your Agent\u2019s performance, behavior, and identify areas of improvement. Just head over to OpenLIT at   on your browser to start exploring. You can login using the default credentials OpenLIT Dashboard Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/mlflow-observability", "title": "Agent Monitoring with MLflow - CrewAI", "content": "Quickly start monitoring your Agents with MLflow.  is an open-source platform to assist machine learning practitioners and teams in handling the complexities of the machine learning process. It provides a tracing feature that enhances LLM observability in your Generative AI applications by capturing detailed information about the execution of your application\u2019s services.\nTracing provides a way to record the inputs, outputs, and metadata associated with each intermediate step of a request, enabling you to easily pinpoint the source of bugs and unexpected behaviors. Install MLflow package Start MFflow tracking server Initialize MLflow in Your Application Add the following two lines to your application code: Example Usage for tracing CrewAI Agents: Refer to   for more configurations and use cases. Visualize Activities of Agents Now traces for your crewAI agents are captured by MLflow.\nLet\u2019s visit MLflow tracking server to view the traces and get insights into your Agents. Open   on your browser to visit MLflow tracking server. MLflow Tracing Dashboard Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/langtrace-observability", "title": "Agent Monitoring with Langtrace - CrewAI", "content": "How to monitor cost, latency, and performance of CrewAI Agents using Langtrace, an external observability tool. Langtrace is an open-source, external tool that helps you set up observability and evaluations for Large Language Models (LLMs), LLM frameworks, and Vector Databases.\nWhile not built directly into CrewAI, Langtrace can be used alongside CrewAI to gain deep visibility into the cost, latency, and performance of your CrewAI Agents.\nThis integration allows you to log hyperparameters, monitor performance regressions, and establish a process for continuous improvement of your Agents. \n \n Sign up for Langtrace Sign up by visiting  . Create a project Set the project type to   and generate an API key. Install Langtrace in your CrewAI project Use the following command: Import Langtrace Import and initialize Langtrace at the beginning of your script, before any CrewAI imports: Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/agentops-observability", "title": "Agent Monitoring with AgentOps - CrewAI", "content": "Understanding and logging your agent performance with AgentOps. Observability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing,\nhow their agents are interacting with users, and how their agents use external tools and APIs.\nAgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents.  provides session replays, metrics, and monitoring for agents. At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more.\nFor more info, check out the  . AgentOps provides monitoring for agents in development and production.\nIt provides a dashboard for tracking agent performance, session replays, and custom reporting. Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time.\nThis feature is useful for debugging and understanding how agents interact with users as well as other agents. \n \n Create an API Key Create a user API key here:  Configure Your Environment Add your API key to your environment variables: Install AgentOps Install AgentOps with: or Initialize AgentOps Before using   in your script, include these lines: This will initiate an AgentOps session as well as automatically track Crew agents. For further info on how to outfit more complex agentic systems,\ncheck out the   or join the  . Example of a Crew agent that generates job posts. Example of a Crew agent that validates Markdown files. Example of a Crew agent that generates Instagram posts. To get started, create an  . For feature requests or bug reports, please reach out to the AgentOps team on the  . Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/conditional-tasks", "title": "Conditional Tasks - CrewAI", "content": "Learn how to use conditional tasks in a crewAI kickoff Conditional Tasks in crewAI allow for dynamic workflow adaptation based on the outcomes of previous tasks.\nThis powerful feature enables crews to make decisions and execute tasks selectively, enhancing the flexibility and efficiency of your AI-driven processes. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/replay-tasks-from-latest-crew-kickoff", "title": "Replay Tasks from Latest Crew Kickoff - CrewAI", "content": "Replay tasks from the latest crew.kickoff(\u2026) CrewAI provides the ability to replay from a task specified from the latest crew kickoff. This feature is particularly useful when you\u2019ve finished a kickoff and may want to retry certain tasks or don\u2019t need to refetch data over and your agents already have the context saved from the kickoff execution so you just need to replay the tasks you want to. You must run   before you can replay a task.\nCurrently, only the latest kickoff is supported, so if you use  , it will only allow you to replay from the most recent crew run. Here\u2019s an example of how to replay from a task: To use the replay feature, follow these steps: Open your terminal or command prompt. Navigate to the directory where your CrewAI project is located. Run the following commands: To view the latest kickoff task_ids use: Once you have your   to replay, use: Ensure   is installed and configured correctly in your development environment. To replay from a task programmatically, use the following steps: Specify the `task_id` and input parameters for the replay process. Specify the   and input parameters for the replay process. Execute the replay command within a try-except block to handle potential errors. Execute the replay command within a try-except block to handle potential errors. With the above enhancements and detailed functionality, replaying specific tasks in CrewAI has been made more efficient and robust.\nEnsure you follow the commands and steps precisely to make the most of these features. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/kickoff-for-each", "title": "Kickoff Crew for Each - CrewAI", "content": "Kickoff Crew for Each Item in a List CrewAI provides the ability to kickoff a crew for each item in a list, allowing you to execute the crew for each item in the list.\nThis feature is particularly useful when you need to perform the same set of tasks for multiple items. To kickoff a crew for each item in a list, use the   method.\nThis method executes the crew for each item in the list, allowing you to process multiple items efficiently. Here\u2019s an example of how to kickoff a crew for each item in a list: Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/kickoff-async", "title": "Kickoff Crew Asynchronously - CrewAI", "content": "Kickoff a Crew Asynchronously CrewAI provides the ability to kickoff a crew asynchronously, allowing you to start the crew execution in a non-blocking manner.\nThis feature is particularly useful when you want to run multiple crews concurrently or when you need to perform other tasks while the crew is executing. To kickoff a crew asynchronously, use the   method. This method initiates the crew execution in a separate thread, allowing the main thread to continue executing other tasks. : Kickoff multiple independent crews asynchronously, each responsible for generating content on different topics. For example, one crew might research and draft an article on AI trends, while another crew generates social media posts about a new product launch. Each crew operates independently, allowing content production to scale efficiently. : Launch multiple crews asynchronously to conduct market research in parallel. One crew might analyze industry trends, while another examines competitor strategies, and yet another evaluates consumer sentiment. Each crew independently completes its task, enabling faster and more comprehensive insights. : Execute separate crews to independently plan different aspects of a trip. One crew might handle flight options, another handles accommodation, and a third plans activities. Each crew works asynchronously, allowing various components of the trip to be planned simultaneously and independently for faster results. Here\u2019s an example of how to kickoff a crew asynchronously using asyncio and awaiting the result: In this example, we\u2019ll show how to kickoff multiple crews asynchronously and wait for all of them to complete using  : Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/human-input-on-execution", "title": "Human Input on Execution - CrewAI", "content": "Integrating CrewAI with human input during execution in complex decision-making processes and leveraging the full capabilities of the agent\u2019s attributes and tools. Human input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary.\nThis feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively. To integrate human input into agent execution, set the   flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer.\nThis input can provide extra context, clarify ambiguities, or validate the agent\u2019s output. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/force-tool-output-as-result", "title": "Force Tool Output as Result - CrewAI", "content": "Learn how to force tool output as the result in an Agent\u2019s task in CrewAI. In CrewAI, you can force the output of a tool as the result of an agent\u2019s task.\nThis feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution. To force the tool output as the result of an agent\u2019s task, you need to set the   parameter to   when adding a tool to the agent.\nThis parameter ensures that the tool output is captured and returned as the task result, without any modifications by the agent. Here\u2019s an example of how to force the tool output as the result of an agent\u2019s task: Task Execution The agent executes the task using the tool provided. Tool Output The tool generates the output, which is captured as the task result. Agent Interaction The agent may reflect and take learnings from the tool but the output is not modified. Result Return The tool output is returned as the task result without any modifications. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/coding-agents", "title": "Coding Agents - CrewAI", "content": "Learn how to enable your CrewAI Agents to write and execute code, and explore advanced features for enhanced functionality. CrewAI Agents now have the powerful ability to write and execute code, significantly enhancing their problem-solving capabilities. This feature is particularly useful for tasks that require computational or programmatic solutions. To enable code execution for an agent, set the   parameter to   when creating the agent. Here\u2019s an example: Note that   parameter defaults to  . : It is strongly recommended to use more capable models like Claude 3.5 Sonnet and GPT-4 when enabling code execution.\nThese models have a better understanding of programming concepts and are more likely to generate correct and efficient code. : The code execution feature includes error handling. If executed code raises an exception, the agent will receive the error message and can attempt to correct the code or\nprovide alternative solutions. The   parameter, which defaults to 2, controls the maximum number of retries for a task. : To use the code execution feature, you need to install the   package. If not installed, the agent will log an info message:\n\u201cCoding tools not available. Install crewai_tools.\u201d When an agent with code execution enabled encounters a task requiring programming: Task Analysis The agent analyzes the task and determines that code execution is necessary. Code Formulation It formulates the Python code needed to solve the problem. Code Execution The code is sent to the internal code execution tool ( ). Result Interpretation The agent interprets the result and incorporates it into its response or uses it for further problem-solving. Here\u2019s a detailed example of creating an agent with code execution capabilities and using it in a task: In this example, the   can write and execute Python code to perform data analysis tasks. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/multimodal-agents", "title": "Using Multimodal Agents - CrewAI", "content": "Learn how to enable and use multimodal capabilities in your agents for processing images and other non-text content within the CrewAI framework. CrewAI supports multimodal agents that can process both text and non-text content like images. This guide will show you how to enable and use multimodal capabilities in your agents. To create a multimodal agent, simply set the   parameter to   when initializing your agent: When you set  , the agent is automatically configured with the necessary tools for handling non-text content, including the  . The multimodal agent comes pre-configured with the  , which allows it to process images. You don\u2019t need to manually add this tool - it\u2019s automatically included when you enable multimodal capabilities. Here\u2019s a complete example showing how to use a multimodal agent to analyze an image: You can provide additional context or specific questions about the image when creating tasks for multimodal agents. The task description can include specific aspects you want the agent to focus on: When working with multimodal agents, the   is automatically configured with the following schema: The multimodal agent will automatically handle the image processing through its built-in tools, allowing it to: When working with multimodal agents, keep these best practices in mind: Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/customizing-agents", "title": "Customize Agents - CrewAI", "content": "A comprehensive guide to tailoring agents for specific roles, tasks, and advanced customizations within the CrewAI framework. Crafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize. Beyond the basic attributes, CrewAI allows for deeper customization to enhance an agent\u2019s behavior and capabilities significantly. Agents can be customized with specific language models ( ) and function-calling language models ( ), offering advanced control over their processing and decision-making abilities.\nIt\u2019s important to note that setting the   allows for overriding the default crew function-calling language model, providing a greater degree of customization. Adjusting an agent\u2019s performance and monitoring its operations are crucial for efficient task execution. The   attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions.\nThe default value is set to 25, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer. Agents are customized by defining their attributes and tools during initialization. Tools are critical for an agent\u2019s functionality, enabling them to perform specialized tasks.\nThe   attribute should be an array of tools the agent can utilize, and it\u2019s initialized as an empty list by default. Tools can be added or modified post-agent initialization to adapt to new requirements. Controlling an agent\u2019s ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default,\nthe   attribute is now set to  , disabling agents to seek assistance or delegate tasks as needed. This default behavior can be changed to promote collaborative problem-solving and\nefficiency within the CrewAI ecosystem. If needed, delegation can be enabled to suit specific operational requirements. Customizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences,\nequips a nuanced and capable AI team ready for complex challenges. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/llm-connections", "title": "Connect to any LLM - CrewAI", "content": "Comprehensive guide on integrating CrewAI with various Large Language Models (LLMs) using LiteLLM, including supported providers and configuration options. CrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface. By default, CrewAI uses the   model. This is determined by the   environment variable, which defaults to \u201cgpt-4o-mini\u201d if not set.\nYou can easily configure your agents to use a different model or provider as described in this guide. LiteLLM supports a wide range of providers, including but not limited to: For a complete and up-to-date list of supported providers, please refer to the  . To use a different LLM with your CrewAI agents, you have several options: Pass the model name as a string when initializing the agent: When configuring an LLM for your agent, you have access to a wide range of parameters: For a complete list of parameters and their descriptions, refer to the LLM class documentation. You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class: For local models like those provided by Ollama: Download and install Ollama Pull the desired model For example, run   to download the model. Configure your agent You can change the base API URL for any LLM provider by setting the   parameter: This is particularly useful when working with OpenAI-compatible APIs or when you need to specify a different endpoint for your chosen provider. By leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the   for the most up-to-date information on supported models and configuration options. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/custom-manager-agent", "title": "Create Your Own Manager Agent - CrewAI", "content": "Learn how to set a custom agent as the manager in CrewAI, providing more control over task management and coordination. CrewAI allows users to set a specific agent as the manager of the crew, providing more control over the management and coordination of tasks.\nThis feature enables the customization of the managerial role to better fit your project\u2019s requirements. The   attribute allows you to define a custom agent to manage the crew. This agent will oversee the entire process, ensuring that tasks are completed efficiently and to the highest standard. If you\u2019re using the hierarchical process and don\u2019t want to set a custom manager agent, you can specify the language model for the manager: Either   or   must be set when using the hierarchical process. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/hierarchical-process", "title": "Hierarchical Process - CrewAI", "content": "A comprehensive guide to understanding and applying the hierarchical process within your CrewAI projects, updated to reflect the latest coding practices and functionalities. The hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution.\nThis systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy. The hierarchical process is designed to leverage advanced models like GPT-4, optimizing token usage while handling complex tasks with greater efficiency. By default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management,\nwhere a \u2018manager\u2019 agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent can now be either\nautomatically created by CrewAI or explicitly set by the user. To utilize the hierarchical process, it\u2019s essential to explicitly set the process attribute to  , as the default behavior is  .\nDefine a crew with a designated manager and establish a clear chain of command. Assign tools at the agent level to facilitate task delegation and execution by the designated agents under the manager\u2019s guidance.\nTools can also be specified at the task level for precise control over tool availability during task execution. Configuring the   parameter is crucial for the hierarchical process.\nThe system requires a manager LLM to be set up for proper function, ensuring tailored decision-making. Alternatively, you can create a custom manager agent with specific attributes tailored to your project\u2019s management needs. This gives you more control over the manager\u2019s behavior and capabilities. For more details on creating and customizing a manager agent, check out the  . Adopting the hierarchical process in CrewAI, with the correct configurations and understanding of the system\u2019s capabilities, facilitates an organized and efficient approach to project management.\nUtilize the advanced features and customizations to tailor the workflow to your specific needs, ensuring optimal task execution and project success. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/sequential-process", "title": "Sequential Processes - CrewAI", "content": "A comprehensive guide to utilizing the sequential processes for task execution in CrewAI projects. CrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes.\nThis guide outlines how to effectively implement these processes to ensure efficient task execution and project completion. The sequential process ensures tasks are executed one after the other, following a linear progression.\nThis approach is ideal for projects requiring tasks to be completed in a specific order. To use the sequential process, assemble your crew and define tasks in the order they need to be executed. Each task in a sequential process   have an agent assigned. Ensure that every   includes an   parameter. In sequential processes, if an agent has   set to  , they can delegate tasks to other agents in the crew.\nThis feature is automatically set up when there are multiple agents in the crew. Tasks can be executed asynchronously, allowing for parallel processing when appropriate.\nTo create an asynchronous task, set   when defining the task. CrewAI supports both memory and caching features: You can set callbacks at both the task and step level: CrewAI tracks token usage across all tasks and agents. You can access these metrics after execution. This updated documentation ensures that details accurately reflect the latest changes in the codebase and clearly describes how to leverage new features and configurations.\nThe content is kept simple and direct to ensure easy understanding. Was this page helpful?"},
{"url": "https://docs.crewai.com/how-to/create-custom-tools", "title": "Create Custom Tools - CrewAI", "content": "Comprehensive guide on crafting, using, and managing custom tools within the CrewAI framework, including new functionalities and error handling. This guide provides detailed instructions on creating custom tools for the CrewAI framework and how to efficiently manage and utilize these tools,\nincorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools,\nenabling agents to perform a wide range of actions. To create a personalized tool, inherit from   and define the necessary attributes, including the   for input validation, and the   method. Alternatively, you can use the tool decorator  . This approach allows you to define the tool\u2019s attributes and functionality directly within a function,\noffering a concise and efficient way to create specialized tools tailored to your needs. To optimize tool performance with caching, define custom caching strategies using the   attribute. By adhering to these guidelines and incorporating new functionalities and collaboration tools into your tool creation and management processes,\nyou can leverage the full capabilities of the CrewAI framework, enhancing both the development experience and the efficiency of your AI agents. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/llamaindex-tools", "title": "Using LlamaIndex Tools - CrewAI", "content": "Learn how to integrate LlamaIndex tools with CrewAI agents to enhance search-based queries and more. CrewAI seamlessly integrates with LlamaIndex\u2019s comprehensive toolkit for RAG (Retrieval-Augmented Generation) and agentic pipelines, enabling advanced search-based queries and more. Here are the available built-in tools offered by LlamaIndex. To effectively use the LlamaIndexTool, follow these steps: Package Installation Make sure that   package is installed in your Python environment: Install and Use LlamaIndex Follow the LlamaIndex documentation   to set up a RAG/agent pipeline. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/memory", "title": "Memory - CrewAI", "content": "Leveraging memory systems in the CrewAI framework to enhance agent capabilities. The crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents.\nThis system comprises  ,  ,  , and  , each serving a unique purpose in aiding agents to remember,\nreason, and learn from past interactions. : With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses. : Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving. : By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information. When configuring a crew, you can enable and customize each memory component to suit the crew\u2019s objectives and the nature of tasks it will perform.\nBy default, the memory system is disabled, and you can ensure it is active by setting   in the crew configuration.\nThe memory will use OpenAI embeddings by default, but you can change it by setting   to a different model.\nIt\u2019s also possible to initialize the memory instance with your own instance. The \u2018embedder\u2019 only applies to   which uses Chroma for RAG.\nThe   uses SQLite3 to store task results. Currently, there is no way to override these storage implementations.\nThe data storage files are saved into a platform-specific location found using the appdirs package,\nand the name of the project can be overridden using the   environment variable. When configuring memory storage: Example using environment variables:  is a self-improving memory layer for LLM applications, enabling personalized AI experiences. To include user-specific memory you can get your API key   and refer the   for adding user preferences. If you want to access a specific organization and project, you can set the   and   parameters in the memory configuration. Alternatively, you can directly pass the OpenAIEmbeddingFunction to the embedder parameter. Example: Before using Google AI embeddings, ensure you have: You will need to update your   dependencies: Note: To use the cli command you need to have your crew in a file called crew.py in the same directory. Integrating CrewAI\u2019s memory system into your projects is straightforward. By leveraging the provided memory components and configurations,\nyou can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/training", "title": "Training - CrewAI", "content": "Learn how to train your CrewAI agents by giving them feedback early on and get consistent results. The training feature in CrewAI allows you to train your AI agents using the command-line interface (CLI).\nBy running the command  , you can specify the number of iterations for the training process. During training, CrewAI utilizes techniques to optimize the performance of your agents along with human feedback.\nThis helps the agents improve their understanding, decision-making, and problem-solving abilities. To use the training feature, follow these steps: Replace   with the desired number of training iterations and   with the appropriate filename ending with  . To train your crew programmatically, use the following steps: It is important to note that the training process may take some time, depending on the complexity of your agents and will also require your feedback on each iteration. Once the training is complete, your agents will be equipped with enhanced capabilities and knowledge, ready to tackle complex tasks and provide more consistent and valuable insights. Remember to regularly update and retrain your agents to ensure they stay up-to-date with the latest information and advancements in the field. Happy training with CrewAI! \ud83d\ude80 Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/collaboration", "title": "Collaboration - CrewAI", "content": "Exploring the dynamics of agent collaboration within the CrewAI framework, focusing on the newly integrated features for enhanced functionality. Collaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem. The   class has been enriched with several attributes to support advanced functionalities: Delegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew\u2019s overall capability. Setting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs. Consider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow. The integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/processes", "title": "Processes - CrewAI", "content": "Detailed guide on workflow management through processes in CrewAI, with updated implementation details. Processes orchestrate the execution of tasks by agents, akin to project management in human teams.\nThese processes ensure tasks are distributed and executed efficiently, in alignment with a predefined strategy. Processes enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence. To assign a process to a crew, specify the process type upon crew creation to set the execution strategy. For a hierarchical process, ensure to define   or   for the manager agent.  Ensure   and   are defined prior to creating a   object, and for the hierarchical process, either   or   is also required. This method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next. To customize task context, utilize the   parameter in the   class to specify outputs that should be used as context for subsequent tasks. Emulates a corporate hierarchy, CrewAI allows specifying a custom manager agent or automatically creates one, requiring the specification of a manager language model ( ). This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion. The   class is implemented as an enumeration ( ), ensuring type safety and restricting process values to the defined types ( ,  ). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation. The structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents.\nThis documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/llms", "title": "LLMs - CrewAI", "content": "A comprehensive guide to configuring and using Large Language Models (LLMs) in your CrewAI projects CrewAI integrates with multiple LLM providers through LiteLLM, giving you the flexibility to choose the right model for your specific use case. This guide will help you understand how to configure and use different LLM providers in your CrewAI projects. Large Language Models (LLMs) are the core intelligence behind CrewAI agents. They enable agents to understand context, make decisions, and generate human-like responses. Here\u2019s what you need to know: Large Language Models are AI systems trained on vast amounts of text data. They power the intelligence of your CrewAI agents, enabling them to understand and generate human-like text. The context window determines how much text an LLM can process at once. Larger windows (e.g., 128K tokens) allow for more context but may be more expensive and slower. Temperature (0.0 to 1.0) controls response randomness. Lower values (e.g., 0.2) produce more focused, deterministic outputs, while higher values (e.g., 0.8) increase creativity and variability. Each LLM provider (e.g., OpenAI, Anthropic, Google) offers different models with varying capabilities, pricing, and features. Choose based on your needs for accuracy, speed, and cost. There are three ways to configure LLMs in CrewAI. Choose the method that best fits your workflow: The simplest way to get started. Set these variables in your environment: Never commit API keys to version control. Use environment files (.env) or your system\u2019s secret management. CrewAI supports a multitude of LLM providers, each offering unique features, authentication methods, and model capabilities.\nIn this section, you\u2019ll find detailed examples that help you select, configure, and optimize the LLM that best fits your project\u2019s needs. OpenAI Set the following environment variables in your   file: Example usage in your CrewAI project: OpenAI is one of the leading providers of LLMs with a wide range of models and features. Anthropic Example usage in your CrewAI project: Google Set the following environment variables in your   file: Get credentials from your Google Cloud Console and save it to a JSON file with the following code: Example usage in your CrewAI project: Google offers a range of powerful models optimized for different use cases: Azure Example usage in your CrewAI project: AWS Bedrock Example usage in your CrewAI project: Amazon SageMaker Example usage in your CrewAI project: Mistral Set the following environment variables in your   file: Example usage in your CrewAI project: Nvidia NIM Set the following environment variables in your   file: Example usage in your CrewAI project: Nvidia NIM provides a comprehensive suite of models for various use cases, from general-purpose tasks to specialized applications. Groq Set the following environment variables in your   file: Example usage in your CrewAI project: IBM watsonx.ai Set the following environment variables in your   file: Example usage in your CrewAI project: Ollama (Local LLMs) Fireworks AI Set the following environment variables in your   file: Example usage in your CrewAI project: Perplexity AI Set the following environment variables in your   file: Example usage in your CrewAI project: Hugging Face Set the following environment variables in your   file: Example usage in your CrewAI project: SambaNova Set the following environment variables in your   file: Example usage in your CrewAI project: Cerebras Set the following environment variables in your   file: Example usage in your CrewAI project: Cerebras features: Open Router Set the following environment variables in your   file: Example usage in your CrewAI project: Open Router models: CrewAI supports structured responses from LLM calls by allowing you to define a   using a Pydantic model. This enables the framework to automatically parse and validate the output, making it easier to integrate the response into your application without manual post-processing. For example, you can define a Pydantic model to represent the expected response structure and pass it as the   when instantiating the LLM. The model will then be used to convert the LLM output into a structured Python object. Learn how to get the most out of your LLM configuration: Context Window Management CrewAI includes smart context management features: Best practices for context management: Performance Optimization Token Usage Optimization Choose the right context window for your task: Best Practices Remember to regularly monitor your token usage and adjust your configuration as needed to optimize costs and performance. Most authentication issues can be resolved by checking API key format and environment variable names. If you need assistance, these resources are available: Comprehensive documentation for LiteLLM integration and troubleshooting common issues. Report bugs, request features, or browse existing issues for solutions. Connect with other CrewAI users, share experiences, and get help from the community. Best Practices for API Key Security: Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/knowledge", "title": "Knowledge - CrewAI", "content": "What is knowledge in CrewAI and how to use it. Knowledge in CrewAI is a powerful system that allows AI agents to access and utilize external information sources during their tasks.\nThink of it as giving your agents a reference library they can consult while working. Key benefits of using Knowledge: CrewAI supports various types of knowledge sources out of the box: For file-Based Knowledge Sources, make sure to place your files in a   directory at the root of your project.\nAlso, use relative paths from the   directory when creating the source. Here\u2019s an example using string-based knowledge: Here\u2019s another example with the  . The CrewDoclingSource is actually quite versatile and can handle multiple file formats including MD, PDF, DOCX, HTML, and more. You need to install   for the following example to work:  Here are examples of how to use different types of knowledge sources: Knowledge sources automatically chunk content for better processing.\nYou can configure chunking behavior in your knowledge sources: The chunking configuration helps in: You can also configure the embedder for the knowledge store.\nThis is useful if you want to use a different embedder for the knowledge store than the one used for the agents.\nThe   parameter supports various embedding model providers that include: Here\u2019s an example of how to configure the embedder for the knowledge store using Google\u2019s   model: If you need to clear the knowledge stored in CrewAI, you can use the   command with the   option. This is useful when you\u2019ve updated your knowledge sources and want to ensure that the agents are using the most recent information. While knowledge can be provided at the crew level using  , individual agents can also have their own knowledge sources using the   parameter: Benefits of agent-specific knowledge: CrewAI allows you to create custom knowledge sources for any type of data by extending the   class. Let\u2019s create a practical example that fetches and processes space news articles. : : : : This example demonstrates how to: The example uses the  , which: You can customize the API query by modifying the endpoint URL: Content Organization Performance Tips Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/flows", "title": "Flows - CrewAI", "content": "Learn how to create and manage AI workflows using CrewAI Flows. CrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Flows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI\u2019s capabilities. : Easily chain together multiple Crews and tasks to create complex AI workflows. : Flows make it super easy to manage and share state between different tasks in your workflow. : Built on an event-driven model, allowing for dynamic and responsive workflows. : Implement conditional logic, loops, and branching within your workflows. Let\u2019s create a simple Flow where you will use OpenAI to generate a random city in one task and then use that city to generate a fun fact in another task. In the above example, we have created a simple Flow that generates a random city using OpenAI and then generates a fun fact about that city. The Flow consists of two tasks:   and  . The   task is the starting point of the Flow, and the   task listens for the output of the   task. Each Flow instance automatically receives a unique identifier (UUID) in its state, which helps track and manage flow executions. The state can also store additional data (like the generated city and fun fact) that persists throughout the flow\u2019s execution. When you run the Flow, it will: The state\u2019s unique ID and stored data can be useful for tracking flow executions and maintaining context between tasks.  Ensure you have set up your   file to store your  . This key is necessary for authenticating requests to the OpenAI API. The   decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with   are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started. The   decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with   will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument. The   decorator can be used in several ways: : You can pass the name of the method you want to listen to as a string. When that method completes, the listener method will be triggered. : You can pass the method itself. When that method completes, the listener method will be triggered. Accessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow. When you run a Flow, the final output is determined by the last method that completes. The   method returns the output of this final method. Here\u2019s how you can access the final output: In this example, the   is the last method to complete, so its output will be the final output of the Flow.\nThe   method will return the final output, which is then printed to the console. In addition to retrieving the final output, you can also access and update the state within your Flow. The state can be used to store and share data between different methods in the Flow. After the Flow has run, you can access the state to retrieve any information that was added or updated during the execution. Here\u2019s an example of how to update and access the state: In this example, the state is updated by both   and  .\nAfter the Flow has run, you can access the final state to see the updates made by these methods. By ensuring that the final method\u2019s output is returned and providing access to the state, CrewAI Flows make it easy to integrate the results of your AI workflows into larger applications or systems,\nwhile also maintaining and accessing the state throughout the Flow\u2019s execution. Managing state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management,\nallowing developers to choose the approach that best fits their application\u2019s needs. In unstructured state management, all state is stored in the   attribute of the   class.\nThis approach offers flexibility, enabling developers to add or modify state attributes on the fly without defining a strict schema.\nEven with unstructured states, CrewAI Flows automatically generates and maintains a unique identifier (UUID) for each state instance.  The   field is automatically generated and preserved throughout the flow\u2019s execution. You don\u2019t need to manage or set it manually, and it will be maintained even when updating the state with new data. Structured state management leverages predefined schemas to ensure consistency and type safety across the workflow.\nBy using models like Pydantic\u2019s  , developers can define the exact shape of the state, enabling better validation and auto-completion in development environments. Each state in CrewAI Flows automatically receives a unique identifier (UUID) to help track and manage state instances. This ID is automatically generated and managed by the Flow system. By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements. The @persist decorator enables automatic state persistence in CrewAI Flows, allowing you to maintain flow state across restarts or different workflow executions. This decorator can be applied at either the class level or method level, providing flexibility in how you manage state persistence. When applied at the class level, the @persist decorator automatically persists all flow method states: For more granular control, you can apply @persist to specific methods: The persistence system\u2019s architecture emphasizes technical precision and customization options, allowing developers to maintain full control over state management while benefiting from built-in reliability features. The   function in Flows allows you to listen to multiple methods and trigger the listener method when any of the specified methods emit an output. When you run this Flow, the   method will be triggered by the output of either the   or the  .\nThe   function is used to listen to multiple methods and trigger the listener method when any of the specified methods emit an output. The   function in Flows allows you to listen to multiple methods and trigger the listener method only when all the specified methods emit an output. When you run this Flow, the   method will be triggered only when both the   and the   emit an output.\nThe   function is used to listen to multiple methods and trigger the listener method only when all the specified methods emit an output. The   decorator in Flows allows you to define conditional routing logic based on the output of a method.\nYou can specify different routes based on the output of the method, allowing you to control the flow of execution dynamically. In the above example, the   generates a random boolean value and sets it in the state.\nThe   uses the   decorator to define conditional routing logic based on the value of the boolean.\nIf the boolean is  , the method returns  , and if it is  , the method returns  .\nThe   and   listen to the output of the   and execute based on the returned value. When you run this Flow, the output will change based on the random boolean value generated by the  . Creating a flow with multiple crews in CrewAI is straightforward. You can generate a new CrewAI project that includes all the scaffolding needed to create a flow with multiple crews by running the following command: This command will generate a new CrewAI project with the necessary folder structure. The generated project includes a prebuilt crew called   that is already working. You can use this crew as a template by copying, pasting, and editing it to create other crews. After running the   command, you will see a folder structure similar to the following: In the   folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the   folder contains: You can copy, paste, and edit the   to create other crews. The   file is where you create your flow and connect the crews together. You can define your flow by using the   class and the decorators   and   to specify the flow of execution. Here\u2019s an example of how you can connect the   in the   file: In this example, the   class defines a flow that generates a sentence count, uses the   to generate a poem, and then saves the poem to a file. The flow is kicked off by calling the   method. (Optional) Before running the flow, you can install the dependencies by running: Once all of the dependencies are installed, you need to activate the virtual environment by running: After activating the virtual environment, you can run the flow by executing one of the following commands: or The flow will execute, and you should see the output in the console. Visualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows. CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows. Plots in CrewAI are graphical representations of your AI workflows. They display the various tasks, their connections, and the flow of data between them. This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations. CrewAI provides two convenient methods to generate plots of your flows: If you are working directly with a flow instance, you can generate a plot by calling the   method on your flow object. This method will create an HTML file containing the interactive plot of your flow. This will generate a file named   in your current directory. You can open this file in a web browser to view the interactive plot. If you are working within a structured CrewAI project, you can generate a plot using the command line. This is particularly useful for larger projects where you want to visualize the entire flow setup. This command will generate an HTML file with the plot of your flow, similar to the   method. The file will be saved in your project directory, and you can open it in a web browser to explore the flow. The generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution. The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details. By visualizing your flows, you can gain a clearer understanding of the workflow\u2019s structure, making it easier to debug, optimize, and communicate your AI processes to others. Plotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows. Whether you choose to use the   method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation. If you\u2019re interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example: : This example demonstrates an infinite loop where a background job continually runs to automate email responses. It\u2019s a great use case for tasks that need to be performed repeatedly without manual intervention.  : This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It\u2019s an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows.  : This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks.  : This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It\u2019s a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems.  By exploring these examples, you can gain insights into how to leverage CrewAI Flows for various use cases, from automating repetitive tasks to managing complex, multi-step processes with dynamic decision-making and human feedback. Also, check out our YouTube video on how to use flows in CrewAI below! There are two ways to run a flow: You can run a flow programmatically by creating an instance of your flow class and calling the   method: Starting from version 0.103.0, you can run flows using the   command: This command automatically detects if your project is a flow (based on the   setting in your pyproject.toml) and runs it accordingly. This is the recommended way to run flows from the command line. For backward compatibility, you can also use: However, the   command is now the preferred method as it works for both crews and flows. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/crews", "title": "Crews - CrewAI", "content": "Understanding and utilizing crews in the crewAI framework with comprehensive attributes and functionalities. A crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow. : The   attribute sets the maximum number of requests per minute the crew can perform to avoid rate limits and will override individual agents\u2019   settings if you set it. There are two ways to create crews in CrewAI: using   or defining them  . Using YAML configuration provides a cleaner, more maintainable way to define crews and is consistent with how agents and tasks are defined in CrewAI projects. After creating your CrewAI project as outlined in the   section, you can define your crew in a class that inherits from   and uses decorators to define agents, tasks, and the crew itself. Tasks will be executed in the order they are defined. The   class, along with these decorators, automates the collection of agents and tasks, reducing the need for manual management. CrewAI provides several decorators in the   file that are used to mark methods within your crew class for special handling: These decorators help in organizing your crew\u2019s structure and automatically collecting agents and tasks without manually listing them. Alternatively, you can define the crew directly in code without using YAML configuration files. In this example: The output of a crew in the CrewAI framework is encapsulated within the   class.\nThis class provides a structured way to access results of the crew\u2019s execution, including various formats such as raw strings, JSON, and Pydantic models.\nThe   includes the results from the final task output, token usage, and individual task outputs. Once a crew has been executed, its output can be accessed through the   attribute of the   object. The   class provides various ways to interact with and present this output. You can see real time log of the crew execution, by setting   as a   or a  . Supports logging of events as both   and  .\nIn case of   will save as  . In case of   is set as   or  , the logs will not be populated. Crews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies. Caches can be employed to store the results of tools\u2019 execution, making the process more efficient by reducing the need to re-execute identical tasks. After the crew execution, you can access the   attribute to view the language model (LLM) usage metrics for all tasks executed by the crew. This provides insights into operational efficiency and areas for improvement. Once your crew is assembled, initiate the workflow with the   method. This starts the execution process according to the defined process flow. Once your crew is assembled, initiate the workflow with the appropriate kickoff method. CrewAI provides several methods for better control over the kickoff process:  ,  ,  , and  . These methods provide flexibility in how you manage and execute tasks within your crew, allowing for both synchronous and asynchronous workflows tailored to your needs. You can now replay from a specific task using our CLI command  . The replay feature in CrewAI allows you to replay from a specific task using the command-line interface (CLI). By running the command  , you can specify the   for the replay process. Kickoffs will now save the latest kickoffs returned task outputs locally for you to be able to replay from. To use the replay feature, follow these steps: To view the latest kickoff task IDs, use: Then, to replay from a specific task, use: These commands let you replay from your latest kickoff tasks, still retaining context from previously executed tasks. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/tasks", "title": "Tasks - CrewAI", "content": "Detailed guide on managing and creating tasks within the CrewAI framework. In the CrewAI framework, a   is a specific assignment completed by an  . Tasks provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities. Tasks within CrewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew\u2019s process, enhancing teamwork and efficiency. Tasks can be executed in two ways: The execution flow is defined when creating the crew: There are two ways to create tasks in CrewAI: using   or defining them  . Using YAML configuration provides a cleaner, more maintainable way to define tasks. We strongly recommend using this approach to define tasks in your CrewAI projects. After creating your CrewAI project as outlined in the   section, navigate to the   file and modify the template to match your specific task requirements. Variables in your YAML files (like  ) will be replaced with values from your inputs when running the crew: Here\u2019s an example of how to configure tasks using YAML: To use this YAML configuration in your code, create a crew class that inherits from  : The names you use in your YAML files (  and  ) should match the method names in your Python code. Alternatively, you can define tasks directly in your code without using YAML configuration: Directly specify an   for assignment or let the   CrewAI\u2019s process decide based on roles, availability, etc. Understanding task outputs is crucial for building effective AI workflows. CrewAI provides a structured way to handle task results through the   class, which supports multiple output formats and can be easily passed between tasks. The output of a task in CrewAI framework is encapsulated within the   class. This class provides a structured way to access results of a task, including various formats such as raw output, JSON, and Pydantic models. By default, the   will only include the   output. A   will only include the   or   output if the original   object was configured with   or  , respectively. Once a task has been executed, its output can be accessed through the   attribute of the   object. The   class provides various ways to interact with and present this output. Tasks can depend on the output of other tasks using the   attribute. For example: Task guardrails provide a way to validate and transform task outputs before they\nare passed to the next task. This feature helps ensure data quality and provides\nfeedback to agents when their output doesn\u2019t meet specific criteria. To add a guardrail to a task, provide a validation function through the   parameter: : : : : When a guardrail returns  : Example with retry handling: It\u2019s also important to note that the output of the final task of a crew becomes the final output of the actual crew itself. The   property allows you to define a Pydantic model that the task output should conform to. This ensures that the output is not only structured but also validated according to the Pydantic model. Here\u2019s an example demonstrating how to use output_pydantic: In this example: The   property allows you to define the expected output in JSON format. This ensures that the task\u2019s output is a valid JSON structure that can be easily parsed and used in your application. Here\u2019s an example demonstrating how to use  : In this example: By using output_pydantic or output_json, you ensure that your tasks produce outputs in a consistent and structured format, making it easier to process and utilize the data within your application or across multiple tasks. Leverage tools from the   and   for enhanced task performance and agent interaction. This demonstrates how tasks with specific tools can override an agent\u2019s default set for tailored task execution. In CrewAI, the output of one task is automatically relayed into the next one, but you can specifically define what tasks\u2019 output, including multiple, should be used as context for another task. This is useful when you have a task that depends on the output of another task that is not performed immediately after it. This is done through the   attribute of the task: You can define a task to be executed asynchronously. This means that the crew will not wait for it to be completed to continue with the next task. This is useful for tasks that take a long time to be completed, or that are not crucial for the next tasks to be performed. You can then use the   attribute to define in a future task that it should wait for the output of the asynchronous task to be completed. The callback function is executed after the task is completed, allowing for actions or notifications to be triggered based on the task\u2019s outcome. Once a crew finishes running, you can access the output of a specific task by using the   attribute of the task object: Specifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI\u2019s flexibility. While creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to: These validations help in maintaining the consistency and reliability of task executions within the crewAI framework. Task guardrails provide a powerful way to validate, transform, or filter task outputs before they are passed to the next task. Guardrails are optional functions that execute before the next task starts, allowing you to ensure that task outputs meet specific requirements or formats. You can now specify if a task should create directories when saving its output to a file. This is particularly useful for organizing outputs and ensuring that file paths are correctly structured. Check out the video below to see how to use structured outputs in CrewAI: Tasks are the driving force behind the actions of agents in CrewAI.\nBy properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit.\nEquipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI\u2019s potential,\nensuring agents are effectively prepared for their assignments and that tasks are executed as intended. Was this page helpful?"},
{"url": "https://docs.crewai.com/concepts/agents", "title": "Agents - CrewAI", "content": "Detailed guide on creating and managing agents within the CrewAI framework. In the CrewAI framework, an   is an autonomous unit that can: Think of an agent as a specialized team member with specific skills, expertise, and responsibilities. For example, a   agent might excel at gathering and analyzing information, while a   agent might be better at creating content. There are two ways to create agents in CrewAI: using   or defining them  . Using YAML configuration provides a cleaner, more maintainable way to define agents. We strongly recommend using this approach in your CrewAI projects. After creating your CrewAI project as outlined in the   section, navigate to the   file and modify the template to match your requirements. Variables in your YAML files (like  ) will be replaced with values from your inputs when running the crew: Here\u2019s an example of how to configure agents using YAML: To use this YAML configuration in your code, create a crew class that inherits from  : The names you use in your YAML files ( ) should match the method names in your Python code. You can create agents directly in code by instantiating the   class. Here\u2019s a comprehensive example showing all available parameters: Let\u2019s break down some key parameter combinations for common use cases: When using custom templates, you can use variables like  ,  , and   in your templates. These will be automatically populated during execution. Agents can be equipped with various tools to enhance their capabilities. CrewAI supports tools from: Here\u2019s how to add tools to an agent: Agents can maintain memory of their interactions and use context from previous tasks. This is particularly useful for complex workflows where information needs to be retained across multiple tasks. When   is enabled, the agent will maintain context across multiple interactions, improving its ability to handle complex, multi-step tasks. : If you\u2019re hitting API rate limits: : If you\u2019re exceeding context limits: : If code execution fails: : If agent responses seem inconsistent: Remember that agents are most effective when configured according to their specific use case. Take time to understand your requirements and adjust these parameters accordingly. Was this page helpful?"},
{"url": "https://docs.crewai.com/quickstart", "title": "Quickstart - CrewAI", "content": "Build your first AI agent with CrewAI in under 5 minutes. Let\u2019s create a simple crew that will help us   and   on the   for a given topic or subject. Before we proceed, make sure you have finished installing CrewAI.\nIf you haven\u2019t installed them yet, you can do so by following the  . Follow the steps below to get Crewing! \ud83d\udea3\u200d\u2642\ufe0f Create your crew Create a new crew project by running the following command in your terminal.\nThis will create a new directory called   with the basic structure for your crew. Navigate to your new crew project Modify your `agents.yaml` file You can also modify the agents as needed to fit your use case or copy and paste as is to your project.\nAny variable interpolated in your   and   files like   will be replaced by the value of the variable in the   file. Modify your `tasks.yaml` file Modify your `crew.py` file [Optional] Add before and after crew functions Feel free to pass custom inputs to your crew For example, you can pass the   input to your crew to customize the research and reporting. Set your environment variables Before running your crew, make sure you have the following keys set as environment variables in your   file: Lock and install the dependencies Run your crew View your final report You should see the output in the console and the   file should be created in the root of your project with the final report. Here\u2019s an example of what the report should look like: Congratulations! You have successfully set up your crew project and are ready to start building your own agentic workflows! The names you use in your YAML files (  and  ) should match the method names in your Python code.\nFor example, you can reference the agent for specific tasks from   file.\nThis naming consistency allows CrewAI to automatically link your configurations with your code; otherwise, your task won\u2019t recognize the reference properly. Note how we use the same name for the agent in the   ( ) file as the method name in the   ( ) file. Note how we use the same name for the agent in the   ( ) file as the method name in the   ( ) file. The easiest way to deploy your crew is through  , where you can deploy your crew in a few clicks. Get started with CrewAI Enterprise and deploy your crew in a production environment with just a few clicks. Join our open source community to discuss ideas, share your projects, and connect with other CrewAI developers. Was this page helpful?"},
{"url": "https://docs.crewai.com/installation", "title": "Installation - CrewAI", "content": "Get started with CrewAI - Install, configure, and build your first AI crew CrewAI requires  . Here\u2019s how to check your version: If you need to update Python, visit  CrewAI uses the   as its dependency management and package handling tool. It simplifies project setup and execution, offering a seamless experience. If you haven\u2019t installed   yet, follow   to quickly get it set up on your system, else you can skip to  . Install uv Use   to download the script and execute it with  : If your system doesn\u2019t have  , you can use  : Use   to download the script and   to execute it: If you run into any issues, refer to   for more information. Install CrewAI \ud83d\ude80 Run the following command to install   CLI: If you encounter a   warning, run this command to update your shell: To verify that   is installed, run: You should see something like: If you need to update  , run: We recommend using the   template scaffolding for a structured approach to defining agents and tasks. Here\u2019s how to get started: Generate Project Scaffolding Run the   CLI command: This creates a new project with the following structure: Customize Your Project Your project will contain these essential files: Start by editing   and   to define your crew\u2019s behavior. Keep sensitive information like API keys in  . Run your Crew Follow our quickstart guide to create your first CrewAI agent and get hands-on experience. Connect with other developers, get help, and share your CrewAI experiences. Was this page helpful?"},
{"url": "https://docs.crewai.com/guides/advanced/fingerprinting", "title": "Fingerprinting - CrewAI", "content": "Learn how to use CrewAI\u2019s fingerprinting system to uniquely identify and track components throughout their lifecycle. Fingerprints in CrewAI provide a way to uniquely identify and track components throughout their lifecycle. Each  ,  , and   automatically receives a unique fingerprint when created, which cannot be manually overridden. These fingerprints can be used for: A fingerprint is an instance of the   class from the   module. Each fingerprint contains: Fingerprints are automatically generated and assigned when a component is created. Each component exposes its fingerprint through a read-only property. You can add metadata to fingerprints for additional context: Fingerprints are designed to persist and remain unchanged throughout a component\u2019s lifecycle. If you modify a component, the fingerprint remains the same: While you cannot directly set the UUID and creation timestamp, you can create deterministic fingerprints using the   method with a seed: Each fingerprint has the following structure: Was this page helpful?"}
]